Microsoft (R) Macro Assembler (x64) Version 14.44.35215.0   09/06/25 20:32:33
ui512md.asm						     Page 1 - 1


				;
				;			ui512md
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			File:			ui512md.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2024, per MIT License below
				;			Date:			June 20, 2024
				;

								INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
 = 00000001		      C legalnotes	EQU		1
			      C .LIST
			      C ;			legalnotes
			      C ;
			      C ;			File:			legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				This module is very light-weight (less than 2K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; legalnotes
			      C 
								INCLUDE			compile_time_options.inc
			      C ;			compile_time_options
			      C ;
			      C ;			File:			compile_time_options.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License included
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C IFNDEF							compile_time_options_INC
 = 1			      C compile_time_options_INC		EQU			<1>
			      C 
			      C 				INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
			      C legalnotes	EQU		1
			      C .LIST
			      C ;			legalnotes
			      C ;
			      C ;			File:			legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				This module is very light-weight (less than 2K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; legalnotes
			      C 
			      C 
			      C ;			Configuration choices
			      C ;
			      C ;	Note: Choosing these options requires knowledge of the target machine CPU model. If you are unsure of the capabiites of the target machine CPU,
			      C ;	You can use the "CPU-Z" tool. https://www.cpuid.com/downloads/cpu-z/cpu-z_2.09-en.exe 
			      C ;	Basically, Intel Skylake and later can use "Z", Haswell and later can use BMI2, etc. 
			      C ;	Too many processors, options, vendors for me to list here. Go to the CPU vendor specifications, or use the tool to inform your choice.
			      C ;
			      C ;	Note: This is intended to be a mutually exclusive choice (UseZ thru UseQ).
			      C ;	However, the coding of the options selects the "highest" one used and ignores the rest ( If __UseZ ... ELSEIF __UseY ... )
			      C 
 = 00000001		      C __UseZ			EQU				1									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000001		      C __UseQ			EQU				1									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000001		      C __UseBMI2		EQU				1									; Bit manipulation instructions (Haswell and later) ref:https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
			      C ;
 = 00000001		      C __VerifyRegs	EQU				1									; in debug mode, or with unit tests, define routine to verify non-volatile regs 
 = 00000001		      C __CheckAlign	EQU				1									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C ;																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ENDIF			; compile_time_options_INC
			      C 
								INCLUDE			ui512aMacros.inc
			      C ;
			      C ;			ui512aMacros
			      C ;
			      C ;			File:			ui512aMacros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			May 13, 2024
			      C ;
			      C 
			      C IFNDEF			ui512aMacros_INC
 = 1			      C ui512aMacros_INC EQU			<1>
			      C 
			      C 				INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
			      C legalnotes	EQU		1
			      C .LIST
			      C ;			legalnotes
			      C ;
			      C ;			File:			legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				This module is very light-weight (less than 2K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; legalnotes
			      C 
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512a.asm)
			      C 
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C ;
			      C 
			      C ;           Some coding shortcuts
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR 
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C LPVOID			TYPEDEF			PTR VOID
			      C ;			mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ;
			      C ; MemConstants <none>
			      C ;
			      C ;		Define useful constants
			      C ;		Note: this must be first in a data segment aligned (64)
			      C ;
			      C MemConstants	MACRO
			      C ; 
			      C qOnes			QWORD           8 DUP (0ffffffffffffffffh)
			      C zeroQ			DQ				0
			      C 
			      C ;		Return codes commonly used.	
			      C retcode_zero	EQU				0
			      C retcode_one		EQU				1
			      C retcode_neg_one	EQU				-1
			      C ;		Sometimes need to get it from memory, not an immediate value. So:
			      C ret_zero		DD				retcode_zero						
			      C ret_one			DD				retcode_one
			      C ret_neg_one		DD				retcode_neg_one
			      C ret_GPFault		DD				0C0000005h						; Windows code for General Protection Fault
			      C 
			      C ;		Masks commonly used
			      C ;		Record form, which can be used as immediate values. Example: OR	R8D, MASK kMask.b8
			      C kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			      C ;		And as memory, for when immediate simply wont do
			      C mskB0			DB				1
			      C mskB1			DB				2
			      C mskB2			DB				4
			      C mskB3			DB				8
			      C mskB4			DB				16
			      C mskB5			DB				32
			      C mskB6			DB				64
			      C mskB7			DB				128
			      C mskAll8			DB				255
			      C 				ENDM
			      C 
			      C ;==================================================================================================
			      C ;           Notes on x64 calling conventions        specifically "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The callers first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;==================================================================================================
			      C 
			      C ;==================================================================================================
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:
			      C ;	indents and capitalization.
			      C ;
			      C ; LEAF_ENTRY <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the beginning of a leaf function.
			      C ;
			      C ;   A leaf function is one that DOES NOT:
			      C ;
			      C ;   - manipulate non-volatile registers
			      C ;   - manipulate the stack pointer
			      C ;   - call other functions
			      C ;   - reference an exception handler
			      C ;   - contain a prologue
			      C ;   - have any unwind data associated with it
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear
			      C ;
			      C Leaf_Entry		MACRO			Name, Section
			      C Section			SEGMENT			PARA 'CODE'
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			Name
			      C Name			PROC			FRAME
			      C 				.ENDPROLOG
			      C 				ENDM
			      C 
			      C ;
			      C ; LEAF_END <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the end of a leaf function.  It must be paired
			      C ;   with a LEAF_ENTRY macro that includes matching Name and Section
			      C ;   parameters.
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function.  Must match that supplied to
			      C ;          the corresponding LEAF_ENTRY macro.
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear.  Must match that supplied to the corresponding
			      C ;             LEAF_ENTRY macro.
			      C ;
			      C Leaf_End		MACRO			Name, Section
			      C Name			ENDP
			      C Section			ENDS
			      C 				ENDM
			      C 
			      C ;===========================================================================================
			      C ;          Local macros
			      C ;===========================================================================================
			      C 
			      C ;
			      C ; CheckAlign <RAddr>
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C 
			      C CheckAlign		MACRO			Raddr:REQ, ExitLbl:VARARG
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				@F									; Yes, passes test, continue
			      C 				MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			      C 		IFNB	<ExitLbl>
			      C 				JMP				ExitLbl								; Return to caller, with GPFault code in EAX
			      C 		ELSE
			      C 				INT				3									; No, fault
			      C 		ENDIF
			      C @@:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ; VerifyRegs <none>
			      C ;
			      C ;			If option is on, generate a function, callable by unit test routines, 
			      C ;				to save non-volatile registers in passed structure.
			      C ;
			      C IF	__VerifyRegs
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* regstruct)
			      C ;			reg_verify		-	copy non-volatile regs into callers struct of nine qwords) intended for unit tests to verify non-volatile regs are not changed
			      C ;			Prototype:		-	void reg_verify( uu64* regstruct);
			      C ;			regstruct		-	Address of 9 QWORDS in a struct where regs will be copied (in RCX)
			      C ; //			reg_verify		-	save non-volatile regs for verification (debug)
			      C ; //			Prototype		-	void reg_verify ( u64* reg struct)
			      C EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* reg struct)
			      C 
			      C VerifyRegs		MACRO
			      C 				Leaf_Entry		reg_verify, ui512
			      C 				MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
			      C 				MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
			      C 				MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
			      C 				MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
			      C 				MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
			      C 				MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
			      C 				MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
			      C 				MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
			      C 				MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
			      C 				RET
			      C 				Leaf_End		reg_verify, ui512
			      C 				ENDM
			      C ENDIF
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C Zero512			MACRO			dest:REQ
			      C 	IF		__UseZ
			      C 				CheckAlign		dest
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				FOR				idx, < 0, 4 >
			      C 				VMOVDQA64		YM_PTR [ dest ] [ idx * 8 ], YMM4
			      C 				ENDM
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				PXOR			XMM4, XMM4
			      C 				FOR				idx, < 0, 2, 4, 6 >
			      C 				MOVDQA			XM_PTR [ dest ] [ idx * 8 ], XMM4
			      C 				ENDM		
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Zero a 512 bit destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Zero512Q		MACRO			dest:REQ
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C Copy512			MACRO			dest:REQ, src:REQ
			      C 	IF		__UseZ 
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src ] [ 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;
			      C ;			Copy a 512 bit source to destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Copy512Q		MACRO			dest:REQ, src:REQ
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ENDIF	; ui512aMacros_INC
			      C 
								INCLUDE			ui512bMacros.inc
			      C ;
			      C ;			ui512bMacros
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			File:			ui512bMacros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			June 11, 2024
			      C ;	
			      C 
			      C IFNDEF			ui512bMacros_INC
 = 1			      C ui512bMacros_INC EQU		<1>
			      C 
			      C 				INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
			      C legalnotes	EQU		1
			      C .LIST
			      C ;			legalnotes
			      C ;
			      C ;			File:			legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				This module is very light-weight (less than 2K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; legalnotes
			      C 
			      C 
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512b.asm)
			      C 
			      C ;   // void shr_u ( u64* destination, u64* source, u16 bits_to_shift )
			      C ;   // shift supplied source 512bit (8 QWORDS) right, put in destination
			      C EXTERNDEF		shr_u:PROC
			      C 
			      C ;   // void shl_u ( u64* destination, u64* source, u16 bits_to_shift );
			      C ;   // shift supplied source 512bit (8 QWORDS) left, put in destination
			      C EXTERNDEF		shl_u:PROC
			      C 
			      C ;   // void and_u ( u64* destination, u64* lh_op, u64* rh_op );
			      C ;   // logical 'AND' bits in lh_op, rh_op, put result in destination
			      C EXTERNDEF		and_u:PROC
			      C 
			      C ;   // logical 'OR' bits in lh_op, rh_op, put result in destination
			      C ;   // void or_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		or_u:PROC
			      C 
			      C ;   // logical 'XOR' bits in lh_op, rh_op, put result in destination
			      C ;   // void xor_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		xor_u:PROC
			      C 
			      C ;   // logical 'NOT' bits in source, put result in destination
			      C ;	// void not_u( u64* destination, u64* source);
			      C EXTERNDEF		not_u:PROC
			      C 
			      C ;   // find most significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 msb_u( u64* );
			      C ;   // returns: -1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		msb_u:PROC
			      C 
			      C ;   // find least significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 lsb_u( u64* );
			      C ;   // returns: -1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		lsb_u:PROC
			      C 
			      C ;==================================================================================================
			      C 
			      C ; Local macros
			      C 
			      C ; Each word is shifted right, and the bits shifted out are ORd into the next (less significant) word.
			      C ; RCX holds the number of bits to shift right, RBX holds the 64 bit complement for left shift.
			      C ShiftOrR		MACRO			lReg, rReg
			      C 				SHLX			RDX, lReg, RBX					; shift 'bottom' bits to top
			      C 				SHRX			rReg, rReg, RCX					; shift target bits right (leaving zero filled bits at top)
			      C 				OR				rReg, RDX						; OR in new 'top' bits
			      C 				ENDM
			      C 
			      C ; Each word is shifted left, and the bits shifted out are ORd into the next (more significant) word.
			      C ; RCX holds the number of bits to shift left, RBX holds the 64 bit complement for right shift.
			      C ShiftOrL		MACRO			lReg, rReg
			      C 				SHRX			RDX, lReg, RBX					; shift 'top' bits to bottom
			      C 				SHLX			rReg, rReg, RCX					; shift target bits left (leaving zero filled bits at bottom)
			      C 				OR				rReg, RDX						; OR in new 'bottom' bits
			      C 				ENDM
			      C 
			      C ENDIF			; ui512bMacros_INC
			      C 
								INCLUDE			ui512mdMacros.inc
			      C 
			      C ;
			      C ;			ui512mdMacros
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			File:			ui512mdMacros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			June 20, 2024
			      C 
			      C 
			      C IFNDEF			ui512mdMacros_INC
 = 1			      C ui512mdMacros_INC EQU			<1>
			      C 
			      C 				INCLUDE			legalnotes.inc
			      C 
			      C IFNDEF		legalnotes
			      C legalnotes	EQU		1
			      C .LIST
			      C ;			legalnotes
			      C ;
			      C ;			File:			legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2024, per MIT License below
			      C ;			Date:			August 20, 2025
			      C ;
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				This module is very light-weight (less than 2K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Use for private (hobbyist), or instructional, or as an example for more ambitious projects
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; legalnotes
			      C 
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			signatures (from ui512md.asm)
			      C 
			      C ; //			mult_uT64		-	multiply 512 bit multiplicand by 64 bit multiplier, giving 512 product, 64 bit overflow
			      C ; //			Prototype:		-	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C EXTERNDEF		mult_uT64:PROC	;	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C 
			      C ; //			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, overflow
			      C ; //			Prototype:		-	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C EXTERNDEF		mult_u:PROC		;	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C 
			      C ; //			div_uT64		-	divide 512 bit dividend by 64 bit bit divisor, giving 512 bit quotient and 64 bit remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64 divisor,);
			      C EXTERNDEF		div_uT64:PROC	;	s16 div_uT64( u64* quotient, u64* remainder, u64* dividend, u64 divisor);
			      C 
			      C ; //			div_u			-	divide 512 bit dividend by 512 bit divisor, giving 512 bit quotient and remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C EXTERNDEF		div_u:PROC		;	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C 
			      C ;==================================================================================================
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:
			      C ;	indents and capitalization.
			      C ;
			      C ; OTHER_ENTRY <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the beginning of a function.
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear
			      C ;
			      C Other_Entry		MACRO			Name, Section
			      C Section			SEGMENT			PARA 'CODE'
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				ENDM
			      C 
			      C ; OTHER_END <Name>, <Section>
			      C ;
			      C ; Macro Description:
			      C ;
			      C ;   This macro indicates the end of a function.  It must be paired
			      C ;   with a OTHER_ENTRY macro that includes matching Name and Section
			      C ;   parameters.
			      C ;
			      C ; Arguments:
			      C ;
			      C ;   Name - Supplies the name of the function.  Must match that supplied to
			      C ;          the corresponding OTHER_ENTRY macro.
			      C ;
			      C ;   Section - Supplies the name of the section within which the function
			      C ;             is to appear.  Must match that supplied to the corresponding
			      C ;             OTHER_ENTRY macro.
			      C ;
			      C Other_Exit		MACRO			Name, Section
			      C Section			ENDS
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			set up frame to save regs, and to create aligned working memory for scratch variables
			      C ;			argsize is the amount of space to be made on the stack for locals and padding (at least 40h on each end)
			      C ;			argsavename is the name of the variable, within the LOCAL declarations, QWORD, for the RBP to be saved, and restored from
			      C ;			No prologue, epilogue should be used. LOCAL declarations immediately after PROC statement, then this macro
			      C ;			Note: LOCAL variables will START on a 64 byte aligned address space. Your order and sizes of your variables will be in sequence as declared
			      C ;			and thus provide no assurance of alignment other than what your declarations imply. In other words, declaring a byte var at the beginning
			      C ;			throws everyting after that off by a byte. OK, not exacly, the asm will align by data type (eg, QWORD on 8 byte), but there is no way to get back
			      C ;			to 64 byte alignment, so declare those first, then QWORD, then DWORD, etc. Or, count your declares such that you get what/where you want.
			      C ;			example:
			      C ;
			      C ;somename	PROC
			      C ;			LOCAL		padding1[8]:QWORD				; warning: do not touch, initialize, or use padding. (on either end)
			      C ;			LOCAL		somelocal:ZMMWORD				; a 512 bit, 64 byte aligned var, ready for aligned load/store into ZMM (AVX2) register
			      C ;			LOCAL		some local variable declarions, some more, and some more
			      C ;			LOCAL		and some more
			      C ;			LOCAL		savedRBP:QWORD					; you might have other reg save space as well
			      C ;			LOCAL		padding2[8]:QWORD				; after your return statement, before ENDP, might LEA padding1 and padding2 to eliminate warning (unreferenced variables)
			      C ;			CREATEFRAME 200h, savedRBP					; (200h assumes 118h in those "some local variable declarations", adjust as necessary)
			      C ;
			      C ;			Use only one return from the PROC, and immediately before return, use ReleaseFrame macro, giving name of where RBP is saved
			      C ;
			      C CreateFrame		MACRO			argsize, argsavename
			      C 				PUSH			RBP
			      C 				MOV				RBP, RSP
			      C 				AND				RSP, -8
			      C 				SUB				RSP, argsize + 64					; make a gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
			      C 				MOV				RAX, -64							; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
			      C 				AND				RAX, RBP							; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
			      C 				XCHG			RAX, RBP							; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
			      C 				MOV				argsavename, RAX					; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
			      C 				ENDM
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			release memory set up by createframe macro
			      C ;			restores RSP, and RBP to as-called values
			      C ;			after these instructions are executed, LOCAL variables can NOT be accessed
			      C ;			This needs to be done to restore the stack correctly, but can be done only once
			      C ;			Strongly suggest doing this just prior to return instruction, and that there is only one return instruction from the PROC
			      C 				ReleaseFrame	MACRO			argsavename
			      C 				MOV				RSP, argsavename					; restore unadjusted / unrounded (the as when called) stack pointer (eliminating LOCAL storage) 
			      C 				POP				RBP									; restore base pointer for caller
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;==========================================================================================
			      C ;           Notes on x64 calling conventions        aka "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ;===========================================================================================
			      C ;
			      C ;===========================================================================================
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;===========================================================================================
			      C 
			      C ENDIF
			      C 

								OPTION			CASEMAP:NONE
								OPTION			PROLOGUE:NONE
								OPTION			EPILOGUE:NONE

 00000000			ui512D			SEGMENT			"CONST" ALIGN (64)					; Declare a data segment. Read only. Aligned 64.

								MemConstants
			     1	; 
 00000000  00000008 [	     1	qOnes			QWORD           8 DUP (0ffffffffffffffffh)
	    FFFFFFFFFFFFFFFF
	   ]
 00000040		     1	zeroQ			DQ				0
	   0000000000000000
			     1	
			     1	;		Return codes commonly used.	
 = 00000000		     1	retcode_zero	EQU				0
 = 00000001		     1	retcode_one		EQU				1
 =-00000001		     1	retcode_neg_one	EQU				-1
			     1	;		Sometimes need to get it from memory, not an immediate value. So:
 00000048 00000000	     1	ret_zero		DD				retcode_zero						
 0000004C 00000001	     1	ret_one			DD				retcode_one
 00000050 FFFFFFFF	     1	ret_neg_one		DD				retcode_neg_one
 00000054 C0000005	     1	ret_GPFault		DD				0C0000005h						; Windows code for General Protection Fault
			     1	
			     1	;		Masks commonly used
			     1	;		Record form, which can be used as immediate values. Example: OR	R8D, MASK kMask.b8
			     1	kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			     1	;		And as memory, for when immediate simply wont do
 00000058 01		     1	mskB0			DB				1
 00000059 02		     1	mskB1			DB				2
 0000005A 04		     1	mskB2			DB				4
 0000005B 08		     1	mskB3			DB				8
 0000005C 10		     1	mskB4			DB				16
 0000005D 20		     1	mskB5			DB				32
 0000005E 40		     1	mskB6			DB				64
 0000005F 80		     1	mskB7			DB				128
 00000060 FF		     1	mskAll8			DB				255

				; end of memory resident constants
 00000061			ui512D			ENDS												; end of data segment

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		mult_u:PROC					; s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier)
				;			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, 512 overflow
				;			Prototype:		-	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
				;			product			-	Address of 8 QWORDS to store resulting product (in RCX)
				;			overflow		-	Address of 8 QWORDS to store resulting overflow (in RDX)
				;			multiplicand	-	Address of 8 QWORDS multiplicand (in R8)
				;			multiplier		-	Address of 8 QWORDS multiplier (in R9)
				;			returns			-	(0) for success, (GP_Fault) for mis-aligned parameter address
				;
						
								Other_Entry		mult_u, ui512
 00000000		     1	ui512			SEGMENT			PARA 'CODE'
 00000000  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
			     1					ALIGN			16
 00000010			mult_u			PROC			PUBLIC
								LOCAL			padding1 [ 8 ] : QWORD
								LOCAL			product [ 16 ] : QWORD
								LOCAL			savedRBP : QWORD
								LOCAL			savedRCX : QWORD, savedRDX : QWORD, savedR10 : QWORD, savedR11 : QWORD, savedR12 : QWORD
								LOCAL			plierl : WORD						; low limit index of of multiplier (7 - first non-zero)
								LOCAL			candl : WORD						; low limit index of multiplicand
								LOCAL			padding2 [ 16 ] : QWORD
 = padding2 + 64 - padding1	mult_u_ofs		EQU				padding2 + 64 - padding1			; offset is the size of the local memory declarations

								CreateFrame		220h, savedRBP
 00000010  55		     1					PUSH			RBP
 00000011  48/ 8B EC	     1					MOV				RBP, RSP
 00000014  48/ 83 E4 F8	     1					AND				RSP, -8
 00000018  48/ 81 EC	     1					SUB				RSP, 220h + 64					; make a gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
	   00000260
 0000001F  48/ C7 C0	     1					MOV				RAX, -64							; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
	   FFFFFFC0
 00000026  48/ 23 C5	     1					AND				RAX, RBP							; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
 00000029  48/ 95	     1					XCHG			RAX, RBP							; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
 0000002B  48/ 89 85	     1					MOV				savedRBP, RAX					; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
	   FFFFFF38
 00000032  48/ 89 8D						MOV				savedRCX, RCX
	   FFFFFF30
 00000039  48/ 89 95						MOV				savedRDX, RDX
	   FFFFFF28
 00000040  4C/ 89 95						MOV				savedR10, R10
	   FFFFFF20
 00000047  4C/ 89 9D						MOV				savedR11, R11
	   FFFFFF18
 0000004E  4C/ 89 A5						MOV				savedR12, R12
	   FFFFFF10

				; Check passed parameters alignment, since this is checked within frame, need to specify exit / cleanup / unwrap label
								CheckAlign		RCX, @@exit							; (out) Product
			     1		IF	__CheckAlign
 00000055  48/ F7 C1	     1					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 0000005C  74 0B	     1					JZ				@F									; Yes, passes test, continue
 0000005E  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<@@exit>
 00000064  E9 000001B0	     1					JMP				@@exit								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 00000069		     1	@@:
			     1		ENDIF
								CheckAlign		RDX, @@exit							; (out) Overflow
			     1		IF	__CheckAlign
 00000069  48/ F7 C2	     1					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 00000070  74 0B	     1					JZ				@F									; Yes, passes test, continue
 00000072  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<@@exit>
 00000078  E9 0000019C	     1					JMP				@@exit								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 0000007D		     1	@@:
			     1		ENDIF
								CheckAlign		R8, @@exit							; (in) Multiplicand
			     1		IF	__CheckAlign
 0000007D  49/ F7 C0	     1					TEST			R8, 63							; Is specified param aligned 64?
	   0000003F
 00000084  74 0B	     1					JZ				@F									; Yes, passes test, continue
 00000086  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<@@exit>
 0000008C  E9 00000188	     1					JMP				@@exit								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 00000091		     1	@@:
			     1		ENDIF
								CheckAlign		R9, @@exit							; (in) Multiplier
			     1		IF	__CheckAlign
 00000091  49/ F7 C1	     1					TEST			R9, 63							; Is specified param aligned 64?
	   0000003F
 00000098  74 0B	     1					JZ				@F									; Yes, passes test, continue
 0000009A  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<@@exit>
 000000A0  E9 00000174	     1					JMP				@@exit								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 000000A5		     1	@@:
			     1		ENDIF

				; Examine multiplicand, save dimensions, handle edge cases of zero or one
 000000A5  49/ 8B C8						MOV				RCX, R8								; examine multiplicand
 000000A8  E8 00000000 E					CALL			msb_u								; get count to most significant bit (-1 if no bits)
 000000AD  66| 83 F8 00						CMP				AX, 0								
 000000B1  0F 8C 00000183					JL				@@zeroandexit						; msb < 0? multiplicand = 0; exit with product = 0
 000000B7  49/ 8D 11						LEA				RDX, [ R9 ]							; multiplicand = 1?	exit with product = multiplier -> address of multiplier (to be copied to product)
 000000BA  0F 84 000001C2					JE				@@copyandexit
 000000C0  66| C1 E8 06						SHR				AX, 6								; divide msb by 64 to get Nr words
 000000C4  66| 8D 0C 25						LEA				CX, [ 7 ]
	   00000007
 000000CC  66| 2B C8						SUB				CX, AX								; subtract from 7 to get starting (high order, left-most) beginning index
 000000CF  66| 89 8D						MOV				candl, CX							; save off multiplicand index lower limit (eliminate multiplying leading zero words)
	   FFFFFF0C

				; Examine multiplier, save dimensions, handle edge cases of zero or one
 000000D6  49/ 8B C9						MOV				RCX, R9								; examine multiplier
 000000D9  E8 00000000 E					CALL			msb_u								; get count to most significant bit (-1 if no bits)
 000000DE  66| 83 F8 00						CMP				AX, 0								; multiplier = 0? exit with product = 0
 000000E2  0F 8C 00000152					JL				@@zeroandexit
 000000E8  49/ 8D 10						LEA				RDX, [ R8 ]							; multiplier = 1? exit with product = multiplicand -> address of multiplicand (to be copied to product)
 000000EB  0F 84 00000191					JE				@@copyandexit
 000000F1  66| C1 E8 06						SHR				AX, 6								; divide msb by 64 to get Nr words
 000000F5  66| 8D 0C 25						LEA				CX, [ 7 ]
	   00000007
 000000FD  66| 2B C8						SUB				CX, AX								; subtract from 7 to get starting (high order, left-most) beginning index
 00000100  66| 89 8D						MOV				plierl, CX							; save off multiplier index lower limit (eliminate multiplying leading zero words)
	   FFFFFF0E

				; In frame / stack reserved memory, clear 16 qword area for working version of overflow/product; set up indexes for loop
 00000107  48/ 8D 8D						LEA				RCX, product [ 0 ]
	   FFFFFF40
								Zero512			RCX									; clear working copy of overflow, need to start as zero, results are accumulated
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 0000010E  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 00000115  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000117  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000011D  CC		     2					INT				3									; No, fault
			     2			ENDIF
 0000011E		     2	@@:
			     2		ENDIF
 0000011E  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000124  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 0000012A  48/ 8D 4D 80						LEA				RCX, product [ 8 * 8 ]
								Zero512			RCX									; clear working copy of product (they need to be contiguous, so using working copy, not callers)
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 0000012E  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 00000135  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000137  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000013D  CC		     2					INT				3									; No, fault
			     2			ENDIF
 0000013E		     2	@@:
			     2		ENDIF
 0000013E  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000144  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 0000014A  4C/ 8D 1C 25						LEA				R11, [ 7 ] 							; index for multiplier (reduced until less than saved plierl) (outer loop)
	   00000007
 00000152  4D/ 8D 23						LEA				R12, [ R11 ]						; index for multiplicand (reduced until less than saved candl) (inner loop)

				; multiply loop: an outer loop for each non-zero qword of multiplicand, with an inner loop for each non-zero qword of multiplier, results accumulated in 'product'
 00000155			@@multloop:
 00000155  4F/ 8D 14 23						LEA				R10, [ R11 ] [ R12 ]				; R10 holds index for overflow / product work area (results)
 00000159  49/ FF C2						INC				R10									; index for product/overflow 
 0000015C  4B/ 8B 04 E0						MOV				RAX, Q_PTR [ R8 ] [ R12 * 8 ]		; get qword of multiplicand
 00000160  4B/ F7 24 D9						MUL				Q_PTR [ R9 ] [ R11 * 8 ]			; multiply by qword of multiplier
 00000164  4A/ 01 84 D5						ADD				product [ R10 * 8 ], RAX			; accummulate in product, this is low-order 64 bits of result of mul
	   FFFFFF40
 0000016C  49/ FF CA						DEC				R10									; preserves carry flag
 0000016F			@@:
 0000016F  4A/ 11 94 D5						ADC				product [ R10 * 8 ], RDX			; high-order result of 64bit multiply, plus the carry (if any)
	   FFFFFF40
 00000177  48/ 8D 14 25						LEA				RDX, [ 0 ]							; again, preserves carry flag
	   00000000
 0000017F  73 05						JNC				@F									; if adding caused carry, propagate it, else next 
 00000181  49/ FF CA						DEC				R10									; propagating carry
 00000184  7D E9						JGE				@B
 00000186			@@:																	; next qword of multiplicand
 00000186  49/ FF CC						DEC				R12
 00000189  66| 44/ 3B A5					CMP				R12W, candl							; Done with inner loop?
	   FFFFFF0C
 00000191  7D C2						JGE				@@multloop							; no, do it again
 00000193  4C/ 8D 24 25						LEA				R12, [ 7 ]							; yes, reset inner loop (multiplicand) index
	   00000007
 0000019B  49/ FF CB						DEC				R11									; decrement index for outer loop
 0000019E  66| 44/ 3B 9D					CMP				R11W, plierl						; done with outer loop?
	   FFFFFF0E
 000001A6  7D AD						JGE				@@multloop							; no, do it again with next qword of multiplier

				; finished: copy working product/overflow to callers product / overflow
 000001A8  48/ 8B 8D						MOV				RCX, savedRCX
	   FFFFFF30
 000001AF  48/ 8D 55 80						LEA				RDX, product [ 8 * 8 ]
								Copy512			RCX, RDX							; copy working product to callers product
			     1		IF		__UseZ 
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 000001B3  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 000001BA  74 07	     2					JZ				@F									; Yes, passes test, continue
 000001BC  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000001C2  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000001C3		     2	@@:
			     2		ENDIF
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 000001C3  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 000001CA  74 07	     2					JZ				@F									; Yes, passes test, continue
 000001CC  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000001D2  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000001D3		     2	@@:
			     2		ENDIF
 000001D3  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000001D9  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					VMOVDQA64		YMM4, YM_PTR [ RDX + 0 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			     1					VMOVDQA64		YMM5, YM_PTR [ RDX ] [ 4 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 4 * 8 ], YMM5
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 0 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 0 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 2 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 2 * 8 ], XMM3
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 4 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 4 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 6 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 6 * 8 ], XMM3
			     1		ELSE
			     1					FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000001DF  48/ 8B 8D						MOV				RCX, savedRDX
	   FFFFFF28
 000001E6  48/ 8D 95						LEA				RDX, product [ 0 ]
	   FFFFFF40
								Copy512			RCX, RDX							; copy working overflow to callers overflow
			     1		IF		__UseZ 
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 000001ED  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 000001F4  74 07	     2					JZ				@F									; Yes, passes test, continue
 000001F6  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000001FC  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000001FD		     2	@@:
			     2		ENDIF
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 000001FD  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 00000204  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000206  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000020C  CC		     2					INT				3									; No, fault
			     2			ENDIF
 0000020D		     2	@@:
			     2		ENDIF
 0000020D  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 00000213  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					VMOVDQA64		YMM4, YM_PTR [ RDX + 0 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			     1					VMOVDQA64		YMM5, YM_PTR [ RDX ] [ 4 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 4 * 8 ], YMM5
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 0 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 0 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 2 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 2 * 8 ], XMM3
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 4 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 4 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 6 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 6 * 8 ], XMM3
			     1		ELSE
			     1					FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF

				; restore regs, release frame, return
 00000219			@@exit:			
 00000219  4C/ 8B 95						MOV				R10, savedR10
	   FFFFFF20
 00000220  4C/ 8B 9D						MOV				R11, savedR11
	   FFFFFF18
 00000227  4C/ 8B A5						MOV				R12, savedR12						; restore any non-volitile regs used
	   FFFFFF10
								ReleaseFrame	savedRBP
 0000022E  48/ 8B A5	     1					MOV				RSP, savedRBP					; restore unadjusted / unrounded (the as when called) stack pointer (eliminating LOCAL storage) 
	   FFFFFF38
 00000235  5D		     1					POP				RBP									; restore base pointer for caller
 00000236  48/ 33 C0						XOR				RAX, RAX							; return zero
								RET
 00000239  C3		   *	    ret    00000h

				; zero callers product and overflow
 0000023A			@@zeroandexit:
 0000023A  48/ 8B 8D						MOV				RCX, savedRCX						; reload address of callers product
	   FFFFFF30
								Zero512			RCX									; zero it
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 00000241  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 00000248  74 07	     2					JZ				@F									; Yes, passes test, continue
 0000024A  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 00000250  CC		     2					INT				3									; No, fault
			     2			ENDIF
 00000251		     2	@@:
			     2		ENDIF
 00000251  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000257  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 0000025D  48/ 8B 8D						MOV				RCX, savedRDX						; reload address of caller overflow
	   FFFFFF28
								Zero512			RCX									; zero it
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 00000264  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 0000026B  74 07	     2					JZ				@F									; Yes, passes test, continue
 0000026D  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 00000273  CC		     2					INT				3									; No, fault
			     2			ENDIF
 00000274		     2	@@:
			     2		ENDIF
 00000274  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000027A  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 00000280  EB 97						JMP				@@exit

				; multiplying by 1: zero overflow, copy the non-one to the product
 00000282			@@copyandexit:
 00000282  48/ 8B 8D						MOV				RCX, savedRDX						; address of passed overflow
	   FFFFFF28
								Zero512			RCX 								; zero it
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 00000289  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 00000290  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000292  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 00000298  CC		     2					INT				3									; No, fault
			     2			ENDIF
 00000299		     2	@@:
			     2		ENDIF
 00000299  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000029F  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000002A5  48/ 8B 8D						MOV				RCX, savedRCX						; copy (whichever: multiplier or multiplicand) to callers product
	   FFFFFF30
								Copy512			RCX, RDX							; RDX "passed" here from whomever jumped here (either &multiplier, or &multiplicand in RDX)
			     1		IF		__UseZ 
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 000002AC  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 000002B3  74 07	     2					JZ				@F									; Yes, passes test, continue
 000002B5  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000002BB  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000002BC		     2	@@:
			     2		ENDIF
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 000002BC  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 000002C3  74 07	     2					JZ				@F									; Yes, passes test, continue
 000002C5  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000002CB  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000002CC		     2	@@:
			     2		ENDIF
 000002CC  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000002D2  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					VMOVDQA64		YMM4, YM_PTR [ RDX + 0 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			     1					VMOVDQA64		YMM5, YM_PTR [ RDX ] [ 4 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 4 * 8 ], YMM5
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 0 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 0 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 2 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 2 * 8 ], XMM3
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 4 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 4 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 6 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 6 * 8 ], XMM3
			     1		ELSE
			     1					FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000002D8  E9 FFFFFF3C						JMP				@@exit								; and exit
								
 000002DD			mult_u			ENDP				
								Other_Exit		mult_u, ui512
 000002DD		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		mult_uT64:PROC				;	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
				;			mult_uT64		-	multiply 512 bit multiplicand by 64 bit multiplier, giving 512 product, 64 bit overflow
				;			Prototype:		-	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
				;			product			-	Address of 8 QWORDS to store resulting product (in RCX)
				;			overflow		-	Address of QWORD for resulting overflow (in RDX)
				;			multiplicand	-	Address of 8 QWORDS multiplicand (in R8)
				;			multiplier		-	multiplier QWORD (in R9)
				;			returns			-	(0) for success, (GP_Fault) for mis-aligned parameter address
								Other_Entry		mult_uT64, ui512
 000002DD		     1	ui512			SEGMENT			PARA 'CODE'
 000002DD  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
			     1					ALIGN			16
 000002F0			mult_uT64		PROC			PUBLIC

				; Check passed parameters alignment, since this is checked within frame, need to specify exit / cleanup / unwrap label
								CheckAlign		RCX, @@exit							; (out) Product
			     1		IF	__CheckAlign
 000002F0  48/ F7 C1	     1					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 000002F7  74 0B	     1					JZ				@F									; Yes, passes test, continue
 000002F9  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<@@exit>
 000002FF  E9 000000BE	     1					JMP				@@exit								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 00000304		     1	@@:
			     1		ENDIF
								CheckAlign		R8, @@exit							; (in) Multiplicand
			     1		IF	__CheckAlign
 00000304  49/ F7 C0	     1					TEST			R8, 63							; Is specified param aligned 64?
	   0000003F
 0000030B  74 0B	     1					JZ				@F									; Yes, passes test, continue
 0000030D  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<@@exit>
 00000313  E9 000000AA	     1					JMP				@@exit								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 00000318		     1	@@:
			     1		ENDIF

				; caller might be doing multiply 'in-place', so need to save the original multiplicand, prior to clearing callers product (A = A * x), or (A *= x)
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								PUSH			Q_PTR [ R8 ] [ idx * 8 ]
								ENDM
 00000318  41/ FF 30	     1					PUSH			Q_PTR [ R8 ] [ 0 * 8 ]
 0000031B  41/ FF 70 08	     1					PUSH			Q_PTR [ R8 ] [ 1 * 8 ]
 0000031F  41/ FF 70 10	     1					PUSH			Q_PTR [ R8 ] [ 2 * 8 ]
 00000323  41/ FF 70 18	     1					PUSH			Q_PTR [ R8 ] [ 3 * 8 ]
 00000327  41/ FF 70 20	     1					PUSH			Q_PTR [ R8 ] [ 4 * 8 ]
 0000032B  41/ FF 70 28	     1					PUSH			Q_PTR [ R8 ] [ 5 * 8 ]
 0000032F  41/ FF 70 30	     1					PUSH			Q_PTR [ R8 ] [ 6 * 8 ]
 00000333  41/ FF 70 38	     1					PUSH			Q_PTR [ R8 ] [ 7 * 8 ]

				; clear callers product and overflow
				;	Note: if caller used multiplicand and product as the same variable (memory space),
				;	this would wipe the multiplicand. Hence the saving of the multiplicand on the stack. (above)
 00000337  48/ 33 C0						XOR				RAX, RAX
								Zero512Q		RCX		   							; clear callers product (multiply uses an addition with carry, so it needs to start zeroed)
 0000033A  48/ 33 C0	     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
 0000033D  48/ 89 01	     2					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 00000340  48/ 89 41 08	     2					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX
 00000344  48/ 89 41 10	     2					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX
 00000348  48/ 89 41 18	     2					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX
 0000034C  48/ 89 41 20	     2					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX
 00000350  48/ 89 41 28	     2					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX
 00000354  48/ 89 41 30	     2					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX
 00000358  48/ 89 41 38	     2					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX
			     1	
 0000035C  48/ 89 02						MOV				Q_PTR [ RDX ], RAX					; clear callers overflow
 0000035F  4C/ 8B D2		 				MOV				R10, RDX							; RDX (pointer to callers overflow) gets used in the MUL: save it in R10

				; FOR EACH index of 7 thru 1 (omiting 0): fetch (pop) qword of multiplicand, multiply, add 128 bit result (RAX, RDX) to running working product
								FOR				idx, < 7, 6, 5, 4, 3, 2, 1 >		; Note: this is not a 'real' for, this is a macro that generates an unwound loop
								POP				RAX									; multiplicand [ idx ] qword -> RAX
								MUL				R9									; times multiplier -> RAX, RDX
								ADD				Q_PTR [ RCX ] [ idx * 8 ], RAX		; add RAX to working product [ idx ] qword
								ADC				Q_PTR [ RCX ] [ (idx - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product
								ENDM
 00000362  58		     1					POP				RAX									; multiplicand [ idx ] qword -> RAX
 00000363  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 00000366  48/ 01 41 38	     1					ADD				Q_PTR [ RCX ] [ 7 * 8 ], RAX		; add RAX to working product [ idx ] qword
 0000036A  48/ 11 51 30	     1					ADC				Q_PTR [ RCX ] [ (7 - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product
 0000036E  58		     1					POP				RAX									; multiplicand [ idx ] qword -> RAX
 0000036F  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 00000372  48/ 01 41 30	     1					ADD				Q_PTR [ RCX ] [ 6 * 8 ], RAX		; add RAX to working product [ idx ] qword
 00000376  48/ 11 51 28	     1					ADC				Q_PTR [ RCX ] [ (6 - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product
 0000037A  58		     1					POP				RAX									; multiplicand [ idx ] qword -> RAX
 0000037B  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 0000037E  48/ 01 41 28	     1					ADD				Q_PTR [ RCX ] [ 5 * 8 ], RAX		; add RAX to working product [ idx ] qword
 00000382  48/ 11 51 20	     1					ADC				Q_PTR [ RCX ] [ (5 - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product
 00000386  58		     1					POP				RAX									; multiplicand [ idx ] qword -> RAX
 00000387  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 0000038A  48/ 01 41 20	     1					ADD				Q_PTR [ RCX ] [ 4 * 8 ], RAX		; add RAX to working product [ idx ] qword
 0000038E  48/ 11 51 18	     1					ADC				Q_PTR [ RCX ] [ (4 - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product
 00000392  58		     1					POP				RAX									; multiplicand [ idx ] qword -> RAX
 00000393  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 00000396  48/ 01 41 18	     1					ADD				Q_PTR [ RCX ] [ 3 * 8 ], RAX		; add RAX to working product [ idx ] qword
 0000039A  48/ 11 51 10	     1					ADC				Q_PTR [ RCX ] [ (3 - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product
 0000039E  58		     1					POP				RAX									; multiplicand [ idx ] qword -> RAX
 0000039F  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 000003A2  48/ 01 41 10	     1					ADD				Q_PTR [ RCX ] [ 2 * 8 ], RAX		; add RAX to working product [ idx ] qword
 000003A6  48/ 11 51 08	     1					ADC				Q_PTR [ RCX ] [ (2 - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product
 000003AA  58		     1					POP				RAX									; multiplicand [ idx ] qword -> RAX
 000003AB  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 000003AE  48/ 01 41 08	     1					ADD				Q_PTR [ RCX ] [ 1 * 8 ], RAX		; add RAX to working product [ idx ] qword
 000003B2  48/ 11 11	     1					ADC				Q_PTR [ RCX ] [ (1 - 1) * 8 ], RDX	; and add RDX with carry to [ idx - 1 ] qword of working product

				; Most significant (idx=0), the high order result of the multiply in RDX, goes to the overflow of the caller
 000003B5  58							POP				RAX
 000003B6  49/ F7 E1						MUL				R9
 000003B9  48/ 01 01						ADD				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 000003BC  49/ 11 12						ADC				Q_PTR [ R10 ], RDX					; last qword overflow is also the operation overflow
 000003BF  48/ 33 C0						XOR				RAX, RAX							; return zero
 000003C2			@@exit:
 000003C2  C3							RET
								
 000003C3			mult_uT64		ENDP
								Other_Exit		mult_uT64, ui512
 000003C3		     1	ui512			ENDS

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		div_u:PROC					; s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor)
				;			div_u			-	divide 512 bit dividend by 512 bit divisor, giving 512 bit quotient and remainder
				;			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
				;			quotient		-	Address of 8 QWORDS to store resulting quotient (in RCX)
				;			remainder		-	Address of 8 QWORDs for resulting remainder (in RDX)
				;			dividend		-	Address of 8 QWORDS dividend (in R8)
				;			divisor			-	Address of 8 QWORDs divisor (in R9)
				;			returns			-	0 for success, -1 for attempt to divide by zero, (GP_Fault) for mis-aligned parameter address

								Other_Entry		div_u, ui512
 000003C3		     1	ui512			SEGMENT			PARA 'CODE'
 000003C3  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
			     1					ALIGN			16
 000003D0			div_u			PROC			PUBLIC
								LOCAL			padding1 [ 16 ] : QWORD
								LOCAL			currnumerator [ 16 ] : QWORD
								LOCAL			qdiv [ 16 ] : QWORD, quotient [ 8 ] : QWORD, normdivisor [ 8 ] : QWORD
								LOCAL			savedRCX : QWORD, savedRDX : QWORD, savedR8 : QWORD, savedR9 : QWORD
								LOCAL			savedR10 : QWORD, savedR11 : QWORD, savedR12 : QWORD, savedRBP : QWORD
								LOCAL			qHat : QWORD, rHat : QWORD,	nDiv : QWORD
								LOCAL			sublen: QWORD, addbackRDX : QWORD, addbackR11 : QWORD
								LOCAL			normf : WORD, jIdx : WORD, mIdx : WORD, nIdx : WORD, mDim : WORD, nDim : Word	
								LOCAL			padding2 [ 16 ] : QWORD
 = padding2 + 64 - padding1	div_oset		EQU				padding2 + 64 - padding1

								CreateFrame		360h, savedRBP
 000003D0  55		     1					PUSH			RBP
 000003D1  48/ 8B EC	     1					MOV				RBP, RSP
 000003D4  48/ 83 E4 F8	     1					AND				RSP, -8
 000003D8  48/ 81 EC	     1					SUB				RSP, 360h + 64					; make a gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
	   000003A0
 000003DF  48/ C7 C0	     1					MOV				RAX, -64							; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
	   FFFFFFC0
 000003E6  48/ 23 C5	     1					AND				RAX, RBP							; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
 000003E9  48/ 95	     1					XCHG			RAX, RBP							; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
 000003EB  48/ 89 85	     1					MOV				savedRBP, RAX					; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
	   FFFFFDC0
 000003F2  48/ 89 8D						MOV				savedRCX, RCX
	   FFFFFDF8
 000003F9  48/ 89 95						MOV				savedRDX, RDX
	   FFFFFDF0
 00000400  4C/ 89 85						MOV				savedR8, R8
	   FFFFFDE8
 00000407  4C/ 89 8D						MOV				savedR9, R9
	   FFFFFDE0
 0000040E  4C/ 89 95						MOV				savedR10, R10
	   FFFFFDD8
 00000415  4C/ 89 9D						MOV				savedR11, R11
	   FFFFFDD0
 0000041C  4C/ 89 A5						MOV				savedR12, R12
	   FFFFFDC8

								CheckAlign		RCX, cleanupwretcode				; (out) Quotient
			     1		IF	__CheckAlign
 00000423  48/ F7 C1	     1					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 0000042A  74 0B	     1					JZ				@F									; Yes, passes test, continue
 0000042C  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<cleanupwretcode>
 00000432  E9 000003A6	     1					JMP				cleanupwretcode								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 00000437		     1	@@:
			     1		ENDIF
								CheckAlign		RDX, cleanupwretcode				; (out) Remainder
			     1		IF	__CheckAlign
 00000437  48/ F7 C2	     1					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 0000043E  74 0B	     1					JZ				@F									; Yes, passes test, continue
 00000440  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<cleanupwretcode>
 00000446  E9 00000392	     1					JMP				cleanupwretcode								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 0000044B		     1	@@:
			     1		ENDIF
								CheckAlign		R8, cleanupwretcode					; (in) Dividend
			     1		IF	__CheckAlign
 0000044B  49/ F7 C0	     1					TEST			R8, 63							; Is specified param aligned 64?
	   0000003F
 00000452  74 0B	     1					JZ				@F									; Yes, passes test, continue
 00000454  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<cleanupwretcode>
 0000045A  E9 0000037E	     1					JMP				cleanupwretcode								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 0000045F		     1	@@:
			     1		ENDIF
								CheckAlign		R9, cleanupwretcode					; (in) Divisor
			     1		IF	__CheckAlign
 0000045F  49/ F7 C1	     1					TEST			R9, 63							; Is specified param aligned 64?
	   0000003F
 00000466  74 0B	     1					JZ				@F									; Yes, passes test, continue
 00000468  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<cleanupwretcode>
 0000046E  E9 0000036A	     1					JMP				cleanupwretcode								; Return to caller, with GPFault code in EAX
			     1			ELSE
			     1					INT				3									; No, fault
			     1			ENDIF
 00000473		     1	@@:
			     1		ENDIF

				; Initialize
								Zero512			RCX									; zero callers quotient
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 00000473  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 0000047A  74 07	     2					JZ				@F									; Yes, passes test, continue
 0000047C  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 00000482  CC		     2					INT				3									; No, fault
			     2			ENDIF
 00000483		     2	@@:
			     2		ENDIF
 00000483  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000489  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
								Zero512			RDX									; zero callers remainder
			     1		IF		__UseZ
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 0000048F  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 00000496  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000498  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000049E  CC		     2					INT				3									; No, fault
			     2			ENDIF
 0000049F		     2	@@:
			     2		ENDIF
 0000049F  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000004A5  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
			     1		ELSEIF	__UseY
			     1					CheckAlign		RDX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RDX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RDX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RDX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RDX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000004AB  48/ 8D 8D						LEA				RCX, quotient
	   FFFFFE40
								Zero512			RCX									; zero working quotient
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 000004B2  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 000004B9  74 07	     2					JZ				@F									; Yes, passes test, continue
 000004BB  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000004C1  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000004C2		     2	@@:
			     2		ENDIF
 000004C2  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000004C8  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF

				 ; Examine divisor
 000004CE  49/ 8B C9						MOV				RCX, R9								; divisor
 000004D1  E8 00000000 E					CALL			msb_u								; get most significant bit
 000004D6  66| 83 F8 00						CMP				AX, 0								; msb < 0? 
 000004DA  0F 8C 00000337					JL				divbyzero							; divisor is zero, abort
 000004E0  0F 84 0000033A					JE				divbyone							; divisor is one, exit with remainder = 0, quotient = dividend 
 000004E6  66| 83 F8 40						CMP				AX, 64								; divisor only one 64-bit word?
 000004EA  7D 54						JGE				mbynDiv								; no, do divide of m digit by n digit

				;	divide of m 64-bit qwords by one 64 bit qword divisor, use the quicker divide routine (div_uT64), and return
 000004EC  48/ 8B 8D						MOV				RCX, savedRCX						; set up parms for call to div by 64bit: RCX - addr of quotient
	   FFFFFDF8
 000004F3  48/ 8B 95						MOV				RDX, savedRDX						; RDX - addr of remainder
	   FFFFFDF0
 000004FA  4C/ 8B 85						MOV				R8, savedR8							; R8 - addr of dividend
	   FFFFFDE8
 00000501  48/ 8B 85						MOV				RAX, savedR9
	   FFFFFDE0
 00000508  4C/ 8B 48 38						MOV				R9, Q_PTR [ RAX ] [ 7 * 8 ]			; R9 - value of 64 bit divisor
 0000050C  E8 000003DF						CALL			div_uT64
 00000511  48/ 8B 95						MOV				RDX, savedRDX						; move 64 bit remainder to last word of 8 word remainder
	   FFFFFDF0
 00000518  48/ 8B 0A						MOV				RCX, Q_PTR [ RDX ]					; get the one qword remainder
								Zero512			RDX									; clear the 8 qword callers remainder
			     1		IF		__UseZ
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 0000051B  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 00000522  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000524  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000052A  CC		     2					INT				3									; No, fault
			     2			ENDIF
 0000052B		     2	@@:
			     2		ENDIF
 0000052B  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000531  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
			     1		ELSEIF	__UseY
			     1					CheckAlign		RDX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RDX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RDX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RDX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RDX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 00000537  48/ 89 4A 38						MOV				Q_PTR [ RDX ] [ 7 * 8 ], RCX		; put the one qword remainder in the least significant qword of the callers remainder
 0000053B  E9 0000029A						JMP				cleanupret

				;
				; Going to divide an 'm' digit dividend (u), by an 'n' digit divisor (v)
				;	See Knuth, The Art of Computer Programming, Volume 2, Algorithm D, Pages 272-278
				;	Notes: This is much like the long division done by hand as taught in school, but instead of digits being 0 to 9, they are 0 to 2^64, or whole 64 bit qwords.
				;	Knuth suggests any base can work, but suggests the selection of one more 'natural' to the machine. Since x64 machines have a 128-bit by 64 bit divide instruction,
				;	The selected base 'b' is one whole qword, or 64 bits, or 2^64. As in manual division, the first non-obvious step is to 'align' the leading bits of the divisor. Knuth calls this
				;	'normalization'. It requires determining the dimensions of the variables, and the most significant bit of the divisor. Both variables are then shifted (left) to get the 
				;	most significant bit of the divisor into the most significant bit of the qword in which it is found. This makes the leading digit of the divisor greter than or equal to 2^64 / 2,
				;	making the first division meaningful. The dividend must then be shifted the same amount.
				;	When the division is completed, no action needs to be taken on the quotient - it will be correct without shifting back (the shifts of dividend and divisor cancel each other out).
				;	The remainder will need to be shifted (right) to "de-normalize" for the return value.
				;	This process yields the dimensions of the variables: the number of qwords in each: 'm' for dividend, 'n' for divisor. Midx, and Nidx are the starting indexes, reflecting m and n.
				;
 00000540			mbynDiv:
 00000540  66| 89 85						MOV				nDim, AX							; still have divisor msb in AX
	   FFFFFD84
 00000547  66| C1 AD						SHR				nDim, 6								; div msb by 64 to get msq (most significant qword) aka 'n' (zero based Nr qwords)
	   FFFFFD84 06
 0000054F  66| B9 0007						MOV				CX, 7
 00000553  66| 2B 8D						SUB				CX, nDim
	   FFFFFD84
						;		INC				nDim
 0000055A  66| 89 8D						MOV				nIdx, CX							; nIdx now 7 - msb of leading word: aka idx to first qword
	   FFFFFD88
								;
 00000561  66| 89 85						MOV				normf, AX
	   FFFFFD8E
 00000568  66| 83 A5						AND				normf, 63
	   FFFFFD8E 3F
 00000570  66| B8 003F						MOV				AX, 63
 00000574  66| 2B 85						SUB				AX, normf							; Nr bits to get leading divisor bit to msb saved at normf
	   FFFFFD8E
 0000057B  66| 89 85						MOV				normf, AX
	   FFFFFD8E
																					
				;	Notes: (continued from above) The mIdx and nIdx are indexes pointing the the leading non-zero qword in dividend and divisor respectively.
				;	jIDx is the number of non-zero qwords in the dividend (after normalization shift). It starts at first non-zero qword

				; Step D1: Normalize	
								
 00000582  48/ 8B 95						MOV				RDX, savedR9						; callers divisor
	   FFFFFDE0
 00000589  48/ 8D 8D						LEA				RCX, normdivisor					; local copy of divisor, normalized
	   FFFFFE00
 00000590  66| 44/ 8B 85					MOV				R8W, normf
	   FFFFFD8E
 00000598  E8 00000000 E					CALL			shl_u								; by shifting until MSB is high bit								
								;
 0000059D  48/ 8B 95						MOV				RDX, savedR8						; callers dividend
	   FFFFFDE8
 000005A4  48/ 8D 8D						LEA				RCX, currnumerator [ 8 * 8 ]		; starting numerator is the normalized supplied dividend
	   FFFFFF40
 000005AB  66| 44/ 8B 85					MOV				R8W, normf							; shifted the same Nr bits as it took to make divisor msb the leading bit
	   FFFFFD8E
 000005B3  E8 00000000 E					CALL			shl_u
 000005B8  48/ 8D 95						LEA				RDX, currnumerator					; zero first eight words of working enumerator
	   FFFFFF00
								Zero512			RDX
			     1		IF		__UseZ
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 000005BF  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 000005C6  74 07	     2					JZ				@F									; Yes, passes test, continue
 000005C8  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000005CE  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000005CF		     2	@@:
			     2		ENDIF
 000005CF  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000005D5  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
			     1		ELSEIF	__UseY
			     1					CheckAlign		RDX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RDX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RDX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RDX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RDX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000005DB  48/ 8B 95						MOV				RDX, savedR8
	   FFFFFDE8
 000005E2  48/ 8B 02						MOV				RAX, Q_PTR [ RDX ]					; if numerator has 8 qwords (dimM = 7), then the shift just lost us high order bits, get them			
 000005E5  66| B9 003F						MOV				CX, 63								; shift first qword of dividend right 
 000005E9  66| 2B 8D						SUB				CX, normf							; by 63 minus Nr bits shifted left
	   FFFFFD8E
 000005F0  48/ D3 E8						SHR				RAX, CL								; eliminating all bit the bits we lost
 000005F3  4C/ 8D A5						LEA				R12, currnumerator [ 7 * 8 ]
	   FFFFFF38
 000005FA  49/ 89 04 24						MOV				[ R12 ], RAX						; store them at m + 1 (the word 'before' the other up to eight qwords)
								;
 000005FE  48/ 33 C0						XOR				RAX, RAX
 00000601  48/ C7 C1						MOV				RCX, -1
	   FFFFFFFF
 00000608			@@:
 00000608  49/ 85 0C C4						TEST			Q_PTR [ R12 ] [ RAX * 8 ], RCX		; R12 currently has addr of beginning of enumerator, 
 0000060C  75 09						JNZ				@F
 0000060E  48/ FF C0						INC				RAX
 00000611  48/ 83 F8 08						CMP				RAX, 8
 00000615  7E F1						JLE				@B
 00000617			@@:
 00000617  4D/ 8D 24 C4						LEA				R12, Q_PTR [ R12 ] [ RAX * 8 ]		; revise beginning address of working numerator with address of first non-zero qword
 0000061B  48/ 8D 0C 25						LEA				RCX, [ 9 ]
	   00000009
 00000623  66| 2B C8						SUB				CX, AX
 00000626  66| 89 8D						MOV				mDim, CX
	   FFFFFD86
 0000062D  66| 89 85						MOV				mIdx, AX							; mIdx after normalize
	   FFFFFD8A
 00000634  66| 89 85						MOV				jIdx, AX							; loop counter (Nr words in denominator)
	   FFFFFD8C
 0000063B  66| 3B 8D						CMP				CX, nDim 
	   FFFFFD84
 00000642  0F 8C 0000023A					JL				numtoremain							; if dimension M (dividend) is less than dimension N (divisor), exit with result zero
 00000648  48/ 0F B7 85						MOVZX			RAX, nIdx							; first word of divisor
	   FFFFFD88
 00000650  48/ 8B 84 C5						MOV				RAX, normdivisor [ RAX * 8 ]
	   FFFFFE00
 00000658  48/ 89 85						MOV				nDiv, RAX							; save and re-use first qword of divisor (used each time to determine qhat)
	   FFFFFDA8
 0000065F  4C/ 8D A5						LEA				R12, currnumerator [ 7 * 8 ]
	   FFFFFF38

				; Step D3: Calculate  q^
 00000666			D3:
 00000666  48/ 0F B7 8D						MOVZX			RCX, jIdx
	   FFFFFD8C
 0000066E  49/ 8B 14 CC						MOV				RDX, Q_PTR [ R12 ] [ RCX * 8 ]
 00000672  48/ FF C1						INC				RCX
 00000675  49/ 8B 04 CC						MOV				RAX, Q_PTR [ R12 ] [ RCX * 8 ]
 00000679  48/ F7 B5						DIV				nDiv
	   FFFFFDA8
 00000680  48/ 89 85						MOV				qHat, RAX
	   FFFFFDB8
 00000687  48/ 89 95						MOV				rHat, RDX
	   FFFFFDB0

				; Step D4: Multiply trial quotient digit by full normalized divisor, then subtract from working copy of numerator (tricky alignment issues)
 0000068E			D4:
 0000068E  48/ 8D 8D						LEA				RCX, qdiv
	   FFFFFE80
								Zero512			RCX
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 00000695  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 0000069C  74 07	     2					JZ				@F									; Yes, passes test, continue
 0000069E  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000006A4  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000006A5		     2	@@:
			     2		ENDIF
 000006A5  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000006AB  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000006B1  48/ 8D 8D						LEA				RCX, qdiv [ 8 * 8 ]					; qdiv is 16 qwords. Last eight are answer
	   FFFFFEC0
 000006B8  48/ 8D 95						LEA				RDX, qdiv [ 7 * 8 ]					; Nr 7 will be overflow (if any)
	   FFFFFEB8
 000006BF  4C/ 8D 85						LEA				R8, normdivisor						; the normalized 8 qword divisor
	   FFFFFE00
 000006C6  4C/ 8B 8D						MOV				R9, qHat							; times qhat
	   FFFFFDB8
 000006CD  E8 FFFFFC1E						CALL			mult_uT64							; multiply divisor by trial quotient digit (qHat)

				; a little intricate here: 	Need the starting address of the two operands, the shorter of the two (remaining) lengths
				; explaining the intricacies: the leading digit of the multiplied number needs to line up with the leading digit of the enumerator @ [ R12 ]
				; the multiply may have added a digit (a qword). The added digit may be in the answer, or may be in the overflow
				; subtract the result of the multiply from the remaining (current) numerator

				; Calculate length of subtraction (sublen)
 000006D2  0F B7 85						MOVZX			EAX, nDim							; number of words in divisor
	   FFFFFD84
 000006D9  0F B7 8D						MOVZX		    ECX, mDim
	   FFFFFD86
 000006E0  66| 2B 8D						SUB				CX, jIdx							; remaining words in numerator
	   FFFFFD8C
 000006E7  48/ 3B C1						CMP				RAX, RCX
 000006EA  48/ 0F 4F C1						CMOVG			RAX, RCX							; sublen = min(nDim, mDim - jIdx)
 000006EE  4C/ 8B C0						MOV				R8, RAX								; R8 = sublen
 000006F1  48/ 89 85						MOV				sublen, RAX	
	   FFFFFDA0

				; Set up pointers for subtraction
 000006F8  48/ 8D 04 25						LEA				RAX, [ 8 ]							; RAX = 8
	   00000008
 00000700  49/ 2B C0						SUB				RAX, R8						
 00000703  48/ 8D 8C C5						LEA			    RCX, qdiv [ RAX * 8 ]				; RCX = start of relevant qdiv
	   FFFFFE80
 0000070B  48/ 0F B7 85						MOVZX			RAX, jIdx
	   FFFFFD8C
 00000713  4A/ 8D 44 00						LEA				RAX, [ RAX ][ R8 ] -1
	   FF
 00000718  48/ 8D 94 C5						LEA			    RDX, currnumerator [ RAX * 8 ]		; RDX = start of relevant currnumerator
	   FFFFFF00

				; Save for possible add-back
 00000720  48/ 89 95						MOV				addbackRDX, RDX
	   FFFFFD98
 00000727  48/ 89 8D						MOV			    addbackR11, RCX
	   FFFFFD90

				; Call subtraction subroutine
 0000072E  E8 0000018E						CALL    @sub

				; Step D5: Test remainder
 00000733			D5:
 00000733  48/ 0F B7 85						MOVZX			RAX, jIdx
	   FFFFFD8C
 0000073B  48/ 8B 8D						MOV				RCX, qHat
	   FFFFFDB8
 00000742  48/ 89 8C C5						MOV				quotient [ RAX * 8 ], RCX			; Set quotient digit [ j ] 
	   FFFFFE40
 0000074A  73 24						JNC				D7									; Carry (from above) indicates result of subtract went negative, need D6 add back, else on to D7

				; Step D6: Add Back
 0000074C			D6:
 0000074C  48/ FF 8C C5						DEC				quotient [ RAX * 8 ]				; adjust quotient digit
	   FFFFFE40
 00000754  4C/ 8B 85						MOV				R8, sublen
	   FFFFFDA0
 0000075B  48/ 8B 8D						MOV				RCX, addbackR11
	   FFFFFD90
 00000762  48/ 8B 95						MOV				RDX, addbackRDX
	   FFFFFD98
 00000769  E8 00000167						CALL			@addback
 0000076E  EB 00						JMP				 D7

				; Step D7: Loop on j
 00000770			D7:
 00000770  66| FF 85						INC				jIdx								; increase loop counter
	   FFFFFD8C
 00000777  66| 83 BD						CMP				jIdx, 8								; done?
	   FFFFFD8C 08
 0000077F  0F 8E FFFFFEE1					JLE				D3									; no, loop to D3

				; Step D8: Un Normalize:
 00000785			D8UnNormalize:
 00000785  48/ 8B 8D						MOV				RCX, savedRDX						; reduced working numerator is now the remainder
	   FFFFFDF0
 0000078C  48/ 8D 95						LEA				RDX, currnumerator [ 8 * 8 ]		; shifted result to callers remainder
	   FFFFFF40
 00000793  66| 44/ 8B 85					MOV				R8W, normf
	   FFFFFD8E
 0000079B  E8 00000000 E					CALL			shr_u
								;
 000007A0  48/ 8B 8D						MOV				RCX, savedRCX						; copy working quotient to callers quotient
	   FFFFFDF8
 000007A7  48/ 8D 95						LEA				RDX, quotient
	   FFFFFE40
								Copy512			RCX, RDX
			     1		IF		__UseZ 
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 000007AE  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 000007B5  74 07	     2					JZ				@F									; Yes, passes test, continue
 000007B7  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000007BD  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000007BE		     2	@@:
			     2		ENDIF
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 000007BE  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 000007C5  74 07	     2					JZ				@F									; Yes, passes test, continue
 000007C7  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000007CD  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000007CE		     2	@@:
			     2		ENDIF
 000007CE  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000007D4  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					VMOVDQA64		YMM4, YM_PTR [ RDX + 0 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			     1					VMOVDQA64		YMM5, YM_PTR [ RDX ] [ 4 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 4 * 8 ], YMM5
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					CheckAlign		RDX
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 0 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 0 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 2 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 2 * 8 ], XMM3
			     1					MOVDQA			XMM4, XM_PTR [ RDX ] [ 4 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 4 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ RDX ] [ 6 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 6 * 8 ], XMM3
			     1		ELSE
			     1					FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				RAX, Q_PTR [ RDX ] [ idx * 8 ]
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000007DA			cleanupret:
 000007DA  48/ 33 C0						XOR				RAX, RAX							; return zero
 000007DD			cleanupwretcode:
 000007DD  4C/ 8B A5						MOV				R12, savedR12
	   FFFFFDC8
 000007E4  4C/ 8B 9D						MOV				R11, savedR11
	   FFFFFDD0
 000007EB  4C/ 8B 95						MOV				R10, savedR10
	   FFFFFDD8
 000007F2  4C/ 8B 8D						MOV				R9,  savedR9
	   FFFFFDE0
 000007F9  4C/ 8B 85						MOV				R8,  savedR8
	   FFFFFDE8
 00000800  48/ 8B 95						MOV				RDX, savedRDX
	   FFFFFDF0
 00000807  48/ 8B 8D						MOV				RCX, savedRCX						; restore parameter registers back to "as-called" values
	   FFFFFDF8
								ReleaseFrame	savedRBP
 0000080E  48/ 8B A5	     1					MOV				RSP, savedRBP					; restore unadjusted / unrounded (the as when called) stack pointer (eliminating LOCAL storage) 
	   FFFFFDC0
 00000815  5D		     1					POP				RBP									; restore base pointer for caller
								RET
 00000816  C3		   *	    ret    00000h
 00000817			divbyzero:
 00000817  8D 04 25						LEA				EAX, [ retcode_neg_one ]
	   FFFFFFFF
 0000081E  EB BD						JMP				cleanupwretcode

 00000820			divbyone:
 00000820  48/ 8B 8D						MOV				RCX, savedRCX						; callers quotient
	   FFFFFDF8
 00000827  4C/ 8B 85						MOV				R8,  savedR8						; callers dividend
	   FFFFFDE8
								Copy512			RCX, R8								; copy dividend to quotient
			     1		IF		__UseZ 
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 0000082E  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 00000835  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000837  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000083D  CC		     2					INT				3									; No, fault
			     2			ENDIF
 0000083E		     2	@@:
			     2		ENDIF
			     1					CheckAlign		R8
			     2		IF	__CheckAlign
 0000083E  49/ F7 C0	     2					TEST			R8, 63							; Is specified param aligned 64?
	   0000003F
 00000845  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000847  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000084D  CC		     2					INT				3									; No, fault
			     2			ENDIF
 0000084E		     2	@@:
			     2		ENDIF
 0000084E  62 41 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ R8 ]
	   38
 00000854  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					CheckAlign		R8
			     1					VMOVDQA64		YMM4, YM_PTR [ R8 + 0 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			     1					VMOVDQA64		YMM5, YM_PTR [ R8 ] [ 4 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RCX ] [ 4 * 8 ], YMM5
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					CheckAlign		R8
			     1					MOVDQA			XMM4, XM_PTR [ R8 ] [ 0 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 0 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ R8 ] [ 2 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 2 * 8 ], XMM3
			     1					MOVDQA			XMM4, XM_PTR [ R8 ] [ 4 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 4 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ R8 ] [ 6 * 8 ]
			     1					MOVDQA			XM_PTR [ RCX ] [ 6 * 8 ], XMM3
			     1		ELSE
			     1					FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				RAX, Q_PTR [ R8 ] [ idx * 8 ]
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 0000085A  48/ 8B 95						MOV				RDX, savedRDX						; callers remainder	
	   FFFFFDF0
								Zero512			RDX									; remainder is zero
			     1		IF		__UseZ
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 00000861  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 00000868  74 07	     2					JZ				@F									; Yes, passes test, continue
 0000086A  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 00000870  CC		     2					INT				3									; No, fault
			     2			ENDIF
 00000871		     2	@@:
			     2		ENDIF
 00000871  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000877  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
			     1		ELSEIF	__UseY
			     1					CheckAlign		RDX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RDX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RDX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RDX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RDX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 0000087D  E9 FFFFFF58						JMP				cleanupret

 00000882  4C/ 8B 85		numtoremain:	MOV				R8, savedR8							; callers dividend
	   FFFFFDE8
 00000889  48/ 8B 95						MOV				RDX, savedRDX						; callers remainder
	   FFFFFDF0
								Copy512			RDX, R8
			     1		IF		__UseZ 
			     1					CheckAlign		RDX
			     2		IF	__CheckAlign
 00000890  48/ F7 C2	     2					TEST			RDX, 63							; Is specified param aligned 64?
	   0000003F
 00000897  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000899  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 0000089F  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000008A0		     2	@@:
			     2		ENDIF
			     1					CheckAlign		R8
			     2		IF	__CheckAlign
 000008A0  49/ F7 C0	     2					TEST			R8, 63							; Is specified param aligned 64?
	   0000003F
 000008A7  74 07	     2					JZ				@F									; Yes, passes test, continue
 000008A9  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 000008AF  CC		     2					INT				3									; No, fault
			     2			ENDIF
 000008B0		     2	@@:
			     2		ENDIF
 000008B0  62 41 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ R8 ]
	   38
 000008B6  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
			     1		ELSEIF	__UseY
			     1					CheckAlign		RDX
			     1					CheckAlign		R8
			     1					VMOVDQA64		YMM4, YM_PTR [ R8 + 0 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RDX ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			     1					VMOVDQA64		YMM5, YM_PTR [ R8 ] [ 4 * 8 ]
			     1					VMOVDQA64		YM_PTR [ RDX ] [ 4 * 8 ], YMM5
			     1		ELSEIF	__UseX
			     1					CheckAlign		RDX
			     1					CheckAlign		R8
			     1					MOVDQA			XMM4, XM_PTR [ R8 ] [ 0 * 8 ]
			     1					MOVDQA			XM_PTR [ RDX ] [ 0 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ R8 ] [ 2 * 8 ]
			     1					MOVDQA			XM_PTR [ RDX ] [ 2 * 8 ], XMM3
			     1					MOVDQA			XMM4, XM_PTR [ R8 ] [ 4 * 8 ]
			     1					MOVDQA			XM_PTR [ RDX ] [ 4 * 8 ], XMM4
			     1					MOVDQA			XMM3, XM_PTR [ R8 ] [ 6 * 8 ]
			     1					MOVDQA			XM_PTR [ RDX ] [ 6 * 8 ], XMM3
			     1		ELSE
			     1					FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				RAX, Q_PTR [ R8 ] [ idx * 8 ]
			     1					MOV				Q_PTR [ RDX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 000008BC  E9 FFFFFF19						JMP				cleanupret
				; subroutine (called) to subtract n digits at [RCX] from [RDX] count of digits in R8
 000008C1  F8			@sub:			CLC
 000008C2  4D/ 85 C0		@@:				TEST			R8,  R8
 000008C5  74 0D						JZ				@e1
 000008C7  4A/ 8B 04 C1						MOV				RAX, Q_PTR [ RCX ] [ R8 * 8 ]
 000008CB  4A/ 19 04 C2						SBB				Q_PTR [ RDX ] [ R8 * 8 ], RAX
 000008CF  49/ FF C8						DEC				R8
 000008D2  EB EE						JMP				@B
 000008D4			@e1:			RET
 000008D4  C3		   *	    ret    00000h

				; subroutine (called) to add (back) n digits at [RCX] to [RDX] count of digits in R8
 000008D5  F8			@addback:		CLC
 000008D6  4D/ 85 C0		@@:				TEST			R8, R8
 000008D9  74 0D						JZ				@e2
 000008DB  4A/ 8B 04 C1						MOV				RAX, Q_PTR [ RCX ] [ R8 * 8 ]
 000008DF  4A/ 11 04 C2						ADC				Q_PTR [ RDX ] [ R8 * 8 ], RAX
 000008E3  49/ FF C8						DEC				R8
 000008E6  EB EE						JMP				@B
 000008E8			@e2:			RET
 000008E8  C3		   *	    ret    00000h

 000008E9			div_u			ENDP
								Other_Exit		div_u, ui512
 000008E9		     1	ui512			ENDS


				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		div_uT64:PROC				; s16 div_uT64( u64* quotient, u64* remainder, u64* dividend, u64 divisor)
				;			div_uT64		-	divide 512 bit dividend by 64 bit divisor, giving 512 bit quotient and 64 bit remainder
				;			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64 divisor);
				;			quotient		-	Address of 8 QWORDS to store resulting quotient (in RCX)
				;			remainder		-	Address of QWORD for resulting remainder (in RDX)
				;			dividend		-	Address of 8 QWORDS dividend (in R8)
				;			divisor			-	Value of 64 bit divisor (in R9)
				;			returns			-	0 for success, -1 for attempt to divide by zero, (GP_Fault) for mis-aligned parameter address
				;
				;			Regs with contents destroyed, not restored: RAX, RDX, R10 (each considered volitile, but caller might optimize on other regs)

								Other_Entry		div_uT64, ui512
 000008E9		     1	ui512			SEGMENT			PARA 'CODE'
 000008E9  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
			     1					ALIGN			16
 000008F0			div_uT64		PROC			PUBLIC
								CheckAlign		RCX									; (out) Quotient
			     1		IF	__CheckAlign
 000008F0  48/ F7 C1	     1					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 000008F7  74 07	     1					JZ				@F									; Yes, passes test, continue
 000008F9  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<>
			     1					JMP												; Return to caller, with GPFault code in EAX
			     1			ELSE
 000008FF  CC		     1					INT				3									; No, fault
			     1			ENDIF
 00000900		     1	@@:
			     1		ENDIF
								CheckAlign		R8									; (in) Dividend
			     1		IF	__CheckAlign
 00000900  49/ F7 C0	     1					TEST			R8, 63							; Is specified param aligned 64?
	   0000003F
 00000907  74 07	     1					JZ				@F									; Yes, passes test, continue
 00000909  8B 05 00000054 R  1					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     1			IFNB	<>
			     1					JMP												; Return to caller, with GPFault code in EAX
			     1			ELSE
 0000090F  CC		     1					INT				3									; No, fault
			     1			ENDIF
 00000910		     1	@@:
			     1		ENDIF

				; Test divisor for divide by zero				
 00000910  4D/ 85 C9						TEST			R9, R9
 00000913  74 63						JZ				@@DivByZero

				; DIV instruction (64-bit) uses RAX and RDX. Need to move RDX (addr of remainder) out of the way; start it off with zero
 00000915  4C/ 8D 12						LEA				R10,  [ RDX ]						; save addr of callers remainder
 00000918  48/ 33 D2						XOR				RDX, RDX

				; FOR EACH index of 0 thru 7: get qword of dividend, divide by divisor, store qword of quotient
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								MOV				RAX, Q_PTR [ R8 ] [ idx * 8 ]		; dividend [ idx ] -> RAX
								DIV				R9									; divide by divisor in R9 (as passed)
								MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
								ENDM
 0000091B  49/ 8B 00	     1					MOV				RAX, Q_PTR [ R8 ] [ 0 * 8 ]		; dividend [ idx ] -> RAX
 0000091E  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 00000921  48/ 89 01	     1					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 00000924  49/ 8B 40 08	     1					MOV				RAX, Q_PTR [ R8 ] [ 1 * 8 ]		; dividend [ idx ] -> RAX
 00000928  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 0000092B  48/ 89 41 08	     1					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 0000092F  49/ 8B 40 10	     1					MOV				RAX, Q_PTR [ R8 ] [ 2 * 8 ]		; dividend [ idx ] -> RAX
 00000933  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 00000936  48/ 89 41 10	     1					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 0000093A  49/ 8B 40 18	     1					MOV				RAX, Q_PTR [ R8 ] [ 3 * 8 ]		; dividend [ idx ] -> RAX
 0000093E  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 00000941  48/ 89 41 18	     1					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 00000945  49/ 8B 40 20	     1					MOV				RAX, Q_PTR [ R8 ] [ 4 * 8 ]		; dividend [ idx ] -> RAX
 00000949  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 0000094C  48/ 89 41 20	     1					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 00000950  49/ 8B 40 28	     1					MOV				RAX, Q_PTR [ R8 ] [ 5 * 8 ]		; dividend [ idx ] -> RAX
 00000954  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 00000957  48/ 89 41 28	     1					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 0000095B  49/ 8B 40 30	     1					MOV				RAX, Q_PTR [ R8 ] [ 6 * 8 ]		; dividend [ idx ] -> RAX
 0000095F  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 00000962  48/ 89 41 30	     1					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 00000966  49/ 8B 40 38	     1					MOV				RAX, Q_PTR [ R8 ] [ 7 * 8 ]		; dividend [ idx ] -> RAX
 0000096A  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 0000096D  48/ 89 41 38	     1					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide

				; Last (least significant qword) divide leaves a remainder, store it at callers remainder
 00000971  49/ 89 12						MOV				Q_PTR [ R10 ], RDX					; remainder to callers remainder
 00000974  48/ 33 C0						XOR				RAX, RAX							; return zero
 00000977			@@exit:			
 00000977  C3							RET

				; Exception handling, divide by zero
 00000978			@@DivByZero:
								Zero512			RCX									; Divide by Zero. Could throw fault, but returning zero quotient, zero remainder
			     1		IF		__UseZ
			     1					CheckAlign		RCX
			     2		IF	__CheckAlign
 00000978  48/ F7 C1	     2					TEST			RCX, 63							; Is specified param aligned 64?
	   0000003F
 0000097F  74 07	     2					JZ				@F									; Yes, passes test, continue
 00000981  8B 05 00000054 R  2					MOV				EAX, ret_GPFault					; Windows code for General Protection Fault	
			     2			IFNB	<>
			     2					JMP												; Return to caller, with GPFault code in EAX
			     2			ELSE
 00000987  CC		     2					INT				3									; No, fault
			     2			ENDIF
 00000988		     2	@@:
			     2		ENDIF
 00000988  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000098E  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
			     1		ELSEIF	__UseY
			     1					CheckAlign		RCX
			     1					VPXORQ			YMM4, YMM4, YMM4
			     1					FOR				idx, < 0, 4 >
			     1					VMOVDQA64		YM_PTR [ RCX ] [ idx * 8 ], YMM4
			     1					ENDM
			     1		ELSEIF	__UseX
			     1					CheckAlign		RCX
			     1					PXOR			XMM4, XMM4
			     1					FOR				idx, < 0, 2, 4, 6 >
			     1					MOVDQA			XM_PTR [ RCX ] [ idx * 8 ], XMM4
			     1					ENDM		
			     1		ELSE
			     1					XOR				RAX, RAX
			     1					FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			     1					MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX
			     1					ENDM
			     1		ENDIF
 00000994  48/ 33 C0						XOR				RAX, RAX
 00000997  49/ 89 02						MOV				Q_PTR [ R10 ] , RAX
 0000099A  8D 04 25						LEA				EAX, [ retcode_neg_one ]			; return error (div by zero)
	   FFFFFFFF
 000009A1  EB D4						JMP				@@exit

 000009A3			div_uT64		ENDP
								Other_Exit		div_uT64, ui512
 000009A3		     1	ui512			ENDS

								END
Microsoft (R) Macro Assembler (x64) Version 14.44.35215.0   09/06/25 20:32:33
ui512md.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512Q . . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
CreateFrame  . . . . . . . . . .	Proc
Leaf_End . . . . . . . . . . . .	Proc
Leaf_Entry . . . . . . . . . . .	Proc
MemConstants . . . . . . . . . .	Proc
Other_Entry  . . . . . . . . . .	Proc
Other_Exit . . . . . . . . . . .	Proc
ReleaseFrame . . . . . . . . . .	Proc
ShiftOrL . . . . . . . . . . . .	Proc
ShiftOrR . . . . . . . . . . . .	Proc
VerifyRegs . . . . . . . . . . .	Proc
Zero512Q . . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

kMask  . . . . . . . . . . . . .	 00000009      00000009
  b8 . . . . . . . . . . . . . .	 00000008      00000001	     0100     ?
  b7 . . . . . . . . . . . . . .	 00000007      00000001	     0080     ?
  b6 . . . . . . . . . . . . . .	 00000006      00000001	     0040     ?
  b5 . . . . . . . . . . . . . .	 00000005      00000001	     0020     ?
  b4 . . . . . . . . . . . . . .	 00000004      00000001	     0010     ?
  b3 . . . . . . . . . . . . . .	 00000003      00000001	     0008     ?
  b2 . . . . . . . . . . . . . .	 00000002      00000001	     0004     ?
  b1 . . . . . . . . . . . . . .	 00000001      00000001	     0002     ?
  b0 . . . . . . . . . . . . . .	 00000000      00000001	     0001     ?


Types:

                N a m e                  Size     Attr

LPVOID . . . . . . . . . . . . .	 00000008     PTR VOID


Segments:

                N a m e                  Length   Align   Class

ui512D . . . . . . . . . . . . .	 00000061 64	  'CONST'	 
ui512  . . . . . . . . . . . . .	 000009A3 16	  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

div_uT64 . . . . . . . . . . . .	P 	 000008F0 ui512	Length= 000000B3 Public
  @@exit . . . . . . . . . . . .	L 	 00000977 ui512	
  @@DivByZero  . . . . . . . . .	L 	 00000978 ui512	
div_u  . . . . . . . . . . . . .	P 	 000003D0 ui512	Length= 00000519 Public
  padding1 . . . . . . . . . . .	QWord	 rbp - 00000080
  currnumerator  . . . . . . . .	QWord	 rbp - 00000100
  qdiv . . . . . . . . . . . . .	QWord	 rbp - 00000180
  quotient . . . . . . . . . . .	QWord	 rbp - 000001C0
  normdivisor  . . . . . . . . .	QWord	 rbp - 00000200
  savedRCX . . . . . . . . . . .	QWord	 rbp - 00000208
  savedRDX . . . . . . . . . . .	QWord	 rbp - 00000210
  savedR8  . . . . . . . . . . .	QWord	 rbp - 00000218
  savedR9  . . . . . . . . . . .	QWord	 rbp - 00000220
  savedR10 . . . . . . . . . . .	QWord	 rbp - 00000228
  savedR11 . . . . . . . . . . .	QWord	 rbp - 00000230
  savedR12 . . . . . . . . . . .	QWord	 rbp - 00000238
  savedRBP . . . . . . . . . . .	QWord	 rbp - 00000240
  qHat . . . . . . . . . . . . .	QWord	 rbp - 00000248
  rHat . . . . . . . . . . . . .	QWord	 rbp - 00000250
  nDiv . . . . . . . . . . . . .	QWord	 rbp - 00000258
  sublen . . . . . . . . . . . .	QWord	 rbp - 00000260
  addbackRDX . . . . . . . . . .	QWord	 rbp - 00000268
  addbackR11 . . . . . . . . . .	QWord	 rbp - 00000270
  normf  . . . . . . . . . . . .	Word	 rbp - 00000272
  jIdx . . . . . . . . . . . . .	Word	 rbp - 00000274
  mIdx . . . . . . . . . . . . .	Word	 rbp - 00000276
  nIdx . . . . . . . . . . . . .	Word	 rbp - 00000278
  mDim . . . . . . . . . . . . .	Word	 rbp - 0000027A
  nDim . . . . . . . . . . . . .	Word	 rbp - 0000027C
  padding2 . . . . . . . . . . .	QWord	 rbp - 000002FC
  mbynDiv  . . . . . . . . . . .	L 	 00000540 ui512	
  D3 . . . . . . . . . . . . . .	L 	 00000666 ui512	
  D4 . . . . . . . . . . . . . .	L 	 0000068E ui512	
  D5 . . . . . . . . . . . . . .	L 	 00000733 ui512	
  D6 . . . . . . . . . . . . . .	L 	 0000074C ui512	
  D7 . . . . . . . . . . . . . .	L 	 00000770 ui512	
  D8UnNormalize  . . . . . . . .	L 	 00000785 ui512	
  cleanupret . . . . . . . . . .	L 	 000007DA ui512	
  cleanupwretcode  . . . . . . .	L 	 000007DD ui512	
  divbyzero  . . . . . . . . . .	L 	 00000817 ui512	
  divbyone . . . . . . . . . . .	L 	 00000820 ui512	
  numtoremain  . . . . . . . . .	L 	 00000882 ui512	
  @sub . . . . . . . . . . . . .	L 	 000008C1 ui512	
  @e1  . . . . . . . . . . . . .	L 	 000008D4 ui512	
  @addback . . . . . . . . . . .	L 	 000008D5 ui512	
  @e2  . . . . . . . . . . . . .	L 	 000008E8 ui512	
mult_uT64  . . . . . . . . . . .	P 	 000002F0 ui512	Length= 000000D3 Public
  @@exit . . . . . . . . . . . .	L 	 000003C2 ui512	
mult_u . . . . . . . . . . . . .	P 	 00000010 ui512	Length= 000002CD Public
  padding1 . . . . . . . . . . .	QWord	 rbp - 00000040
  product  . . . . . . . . . . .	QWord	 rbp - 000000C0
  savedRBP . . . . . . . . . . .	QWord	 rbp - 000000C8
  savedRCX . . . . . . . . . . .	QWord	 rbp - 000000D0
  savedRDX . . . . . . . . . . .	QWord	 rbp - 000000D8
  savedR10 . . . . . . . . . . .	QWord	 rbp - 000000E0
  savedR11 . . . . . . . . . . .	QWord	 rbp - 000000E8
  savedR12 . . . . . . . . . . .	QWord	 rbp - 000000F0
  plierl . . . . . . . . . . . .	Word	 rbp - 000000F2
  candl  . . . . . . . . . . . .	Word	 rbp - 000000F4
  padding2 . . . . . . . . . . .	QWord	 rbp - 00000174
  @@multloop . . . . . . . . . .	L 	 00000155 ui512	
  @@exit . . . . . . . . . . . .	L 	 00000219 ui512	
  @@zeroandexit  . . . . . . . .	L 	 0000023A ui512	
  @@copyandexit  . . . . . . . .	L 	 00000282 ui512	


Symbols:

                N a m e                 Type     Value    Attr

B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000001h   
__UseBMI2  . . . . . . . . . . .	Number	 00000001h   
__UseQ . . . . . . . . . . . . .	Number	 00000001h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000001h   
__VerifyRegs . . . . . . . . . .	Number	 00000001h   
add_uT64 . . . . . . . . . . . .	L 	 00000000 External
add_u  . . . . . . . . . . . . .	L 	 00000000 External
and_u  . . . . . . . . . . . . .	L 	 00000000 External
compare_uT64 . . . . . . . . . .	L 	 00000000 External
compare_u  . . . . . . . . . . .	L 	 00000000 External
compile_time_options_INC . . . .	Text   	 1
copy_u . . . . . . . . . . . . .	L 	 00000000 External
div_oset . . . . . . . . . . . .	Text   	 padding2 + 64 - padding1
legalnotes . . . . . . . . . . .	Number	 00000001h   
lsb_u  . . . . . . . . . . . . .	L 	 00000000 External
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
msb_u  . . . . . . . . . . . . .	L 	 00000000 External
mskAll8  . . . . . . . . . . . .	Byte	 00000060 ui512D	
mskB0  . . . . . . . . . . . . .	Byte	 00000058 ui512D	
mskB1  . . . . . . . . . . . . .	Byte	 00000059 ui512D	
mskB2  . . . . . . . . . . . . .	Byte	 0000005A ui512D	
mskB3  . . . . . . . . . . . . .	Byte	 0000005B ui512D	
mskB4  . . . . . . . . . . . . .	Byte	 0000005C ui512D	
mskB5  . . . . . . . . . . . . .	Byte	 0000005D ui512D	
mskB6  . . . . . . . . . . . . .	Byte	 0000005E ui512D	
mskB7  . . . . . . . . . . . . .	Byte	 0000005F ui512D	
mult_u_ofs . . . . . . . . . . .	Text   	 padding2 + 64 - padding1
not_u  . . . . . . . . . . . . .	L 	 00000000 External
or_u . . . . . . . . . . . . . .	L 	 00000000 External
qOnes  . . . . . . . . . . . . .	QWord	 00000000 ui512D	
reg_verify . . . . . . . . . . .	L 	 00000000 External
ret_GPFault  . . . . . . . . . .	DWord	 00000054 ui512D	
ret_neg_one  . . . . . . . . . .	DWord	 00000050 ui512D	
ret_one  . . . . . . . . . . . .	DWord	 0000004C ui512D	
ret_zero . . . . . . . . . . . .	DWord	 00000048 ui512D	
retcode_neg_one  . . . . . . . .	Number	 -00000001h   
retcode_one  . . . . . . . . . .	Number	 00000001h   
retcode_zero . . . . . . . . . .	Number	 00000000h   
set_uT64 . . . . . . . . . . . .	L 	 00000000 External
shl_u  . . . . . . . . . . . . .	L 	 00000000 External
shr_u  . . . . . . . . . . . . .	L 	 00000000 External
sub_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_u  . . . . . . . . . . . . .	L 	 00000000 External
ui512aMacros_INC . . . . . . . .	Text   	 1
ui512bMacros_INC . . . . . . . .	Text   	 1
ui512mdMacros_INC  . . . . . . .	Text   	 1
xor_u  . . . . . . . . . . . . .	L 	 00000000 External
zeroQ  . . . . . . . . . . . . .	QWord	 00000040 ui512D	
zero_u . . . . . . . . . . . . .	L 	 00000000 External

	   0 Warnings
	   0 Errors
