Microsoft (R) Macro Assembler (x64) Version 14.40.33811.0   06/16/24 18:10:57
ui512md.asm						     Page 1 - 1


				;
				;			ui512md
				;
							INCLUDE         ui512aMacros.inc
			      C .nolist
			      C .list
			      C IFNDEF						ui512aMacros_INC
 = 1			      C ui512aMacros_INC EQU		<1>
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512a.asm)
			      C 
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF	zero_u:PROC
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF	copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF	set_uT64:PROC
			      C 
			      C ;	// int compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF	compare_u:PROC
			      C 
			      C ;	// int compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF	compare_uT64:PROC
			      C 
			      C ;	// void add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources to supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF	add_u:PROC
			      C 
			      C ;	// s32 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF	add_uT64:PROC
			      C 
			      C ;	// s32 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF	sub_u:PROC
			      C 
			      C ;	// s32 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF	sub_uT64:PROC
			      C 
			      C ;			Configuration choices
 = 00000001		      C __UseZ		EQU				1							; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY		EQU				0							; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX		EQU				0							; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000000		      C __UseQ		EQU				0							; Do not use extensions, use standard x64 bit registers and instructions
			      C 
			      C ;           Some coding shortcuts
 = ZMMWORD PTR		      C ZM_PTR      EQU             ZMMWORD PTR
 = YMMWORD PTR		      C YM_PTR      EQU             YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR      EQU             XMMWORD PTR
 = QWORD PTR		      C Q_PTR       EQU             QWORD PTR
 = DWORD PTR		      C D_PTR       EQU             DWORD PTR
 = WORD PTR		      C W_PTR       EQU             WORD PTR
 = BYTE PTR		      C B_PTR       EQU             BYTE PTR
 = DWORD BCST		      C m32BCST     EQU				DWORD BCST
 = QWORD BCST		      C m64BCST     EQU				QWORD BCST
			      C 
			      C ;			mask codes (for compares)
 = 00000000		      C CPEQ		EQU				0
 = 00000001		      C CPLT		EQU				1
 = 00000002		      C CPLE		EQU				2
 = 00000004		      C CPNE		EQU				4
 = 00000005		      C CPGE		EQU				5
 = 00000006		      C CPGT		EQU				6
			      C ;===============================================
			      C ;          Local macros
			      C ;===============================================
			      C 
			      C ;==========================================================================================
			      C ;           Notes on x64 calling conventions        aka "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;===========================================================================================
			      C ;
			      C ;===========================================================================================
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;===========================================================================================
			      C 
			      C Zero512		MACRO			dest
			      C ;
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C 	IF		__UseZ
			      C 			VPXORQ			ZMM31, ZMM31, ZMM31
			      C 			VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 			VPXORQ			YMM4, YMM4, YMM4
			      C 			VMOVDQA64		YM_PTR [ dest ] + [ 0 * 8 ], YMM4
			      C 			VMOVDQA64		YM_PTR [ dest ] + [ 4 * 8 ], YMM4
			      C 	ELSEIF	__UseX
			      C 			PXOR			XMM4, XMM4
			      C 			MOVDQA			XM_PTR [ dest ] + [ 0 * 8 ], XMM4
			      C 			MOVDQA			XM_PTR [ dest ] + [ 2 * 8 ], XMM4
			      C 			MOVDQA			XM_PTR [ dest ] + [ 4 * 8 ], XMM4
			      C 			MOVDQA			XM_PTR [ dest ] + [ 6 * 8 ], XMM4			
			      C 	ELSE
			      C 			XOR				RAX, RAX
			      C 			MOV				[ dest ] + [ 0 * 8 ], RAX
			      C 			MOV				[ dest ] + [ 1 * 8 ], RAX
			      C 			MOV				[ dest ] + [ 2 * 8 ], RAX
			      C 			MOV				[ dest ] + [ 3 * 8 ], RAX
			      C 			MOV				[ dest ] + [ 4 * 8 ], RAX
			      C 			MOV				[ dest ] + [ 5 * 8 ], RAX
			      C 			MOV				[ dest ] + [ 6 * 8 ], RAX
			      C 			MOV				[ dest ] + [ 7 * 8 ], RAX
			      C 	ENDIF
			      C 			ENDM
			      C 
			      C Copy512		MACRO			dest, src
			      C ;
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C 	IF		__UseZ
			      C 			VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 			VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 			VMOVDQA64		YMM4, YM_PTR [ src ] + [ 0 * 8 ]
			      C 			VMOVDQA64		YM_PTR [ dest ] + [ 0 * 8 ], YMM4
			      C 			VMOVDQA64		YMM5, YM_PTR [ src ] + [ 4 * 8 ]
			      C 			VMOVDQA64		YM_PTR [ dest ] + [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 			MOVDQA			XMM4, XM_PTR [ src ] + [ 0 * 8 ]
			      C 			MOVDQA			XM_PTR [ dest ] + [ 0 * 8 ], XMM4
			      C 			MOVDQA			XMM3, XM_PTR [ src ] + [ 2 * 8 ]
			      C 			MOVDQA			XM_PTR [ dest ] + [ 2 * 8 ], XMM3
			      C 			MOVDQA			XMM4, XM_PTR [ src ] + [ 4 * 8 ]
			      C 			MOVDQA			XM_PTR [ dest ] + [ 4 * 8 ], XMM4
			      C 			MOVDQA			XMM3, XM_PTR [ src ] + [ 6 * 8 ]
			      C 			MOVDQA			XM_PTR [ dest ] + [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 			MOV				RAX, [ src ] + [ 0 * 8 ]
			      C 			MOV				[ dest ] + [ 0 * 8 ], RAX
			      C 			MOV				RAX, [ src ] + [ 1 * 8 ]
			      C 			MOV				[ dest ] + [ 1 * 8 ], RAX
			      C 			MOV				RAX, [ src ] + [ 2 * 8 ]
			      C 			MOV				[ dest ] + [ 2 * 8 ], RAX
			      C 			MOV				RAX, [ src ] + [ 3 * 8 ]
			      C 			MOV				[ dest ] + [ 3 * 8 ], RAX
			      C 			MOV				RAX, [ src ] + [ 4 * 8 ]
			      C 			MOV				[ dest ] + [ 4 * 8 ], RAX
			      C 			MOV				RAX, [ src ] + [ 5 * 8 ]
			      C 			MOV				[ dest ] + [ 5 * 8 ], RAX
			      C 			MOV				RAX, [ src ] + [ 6 * 8 ]
			      C 			MOV				[ dest ] + [ 6 * 8 ], RAX
			      C 			MOV				RAX, [ src ] + [ 7 * 8 ]
			      C 			MOV				[ dest ] + [ 7 * 8 ], RAX
			      C 	ENDIF
			      C 			ENDM
			      C 
			      C ENDIF
			      C 
							INCLUDE			ui512bMacros.inc
			      C .nolist
			      C .list
			      C IFNDEF						ui512bMacros_INC
 = 1			      C ui512bMacros_INC EQU		<1>
			      C ;           header file equivalent extern declarations
			      C ;			EXTERN "C" signatures (from ui512b.asm)
			      C 
			      C ;   // void shr_u ( u64* destination, u64* source, u32 bits_to_shift )
			      C ;   // shift supplied source 512bit (8 QWORDS) right, put in destination
			      C EXTERNDEF	shr_u:PROC
			      C 
			      C ;   // void shl_u ( u64* destination, u64* source, u16 bits_to_shift );
			      C ;   // shift supplied source 512bit (8 QWORDS) left, put in destination
			      C EXTERNDEF	shl_u:PROC
			      C 
			      C ;   // void and_u ( u64* destination, u64* lh_op, u64* rh_op );
			      C ;   // logical 'AND' bits in lh_op, rh_op, put result in destination
			      C EXTERNDEF	and_u:PROC
			      C 
			      C ;   // logical 'OR' bits in lh_op, rh_op, put result in destination
			      C ;   // void or_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF	or_u:PROC
			      C 
			      C ;   // logical 'NOT' bits in source, put result in destination
			      C ;	// void not_u( u64* destination, u64* source);
			      C EXTERNDEF	not_u:PROC
			      C 
			      C ;   // find most significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 msb_u( u64* );
			      C ;   // returns: -1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C EXTERNDEF	msb_u:PROC
			      C 
			      C ;   // find least significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 lsb_u( u64* );
			      C ;   // returns: -1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C EXTERNDEF	lsb_u:PROC
			      C 
			      C ENDIF
			      C 
							INCLUDE			ui512mdMacros.inc
			      C ;
			      C IFNDEF						ui512mdMacros_INC
 = 1			      C ui512mdMacros_INC EQU			 <1>
			      C 
			      C 
			      C ;			signatures (from ui512muldiv.asm)
			      C EXTERNDEF	mult_u:PROC					;	void mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C EXTERNDEF	mult_uT64:PROC				;	void mult_uT64( u64* product, u64 overflow, u64* multiplicand, u64 multiplier);
			      C EXTERNDEF	div_u:PROC					;	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C EXTERNDEF	div_uT64:PROC				;	s16 div_uT64( u64* quotient, u64 remainder, u64* dividend, u64 divisor);
			      C 
			      C CreateFrame	MACRO			argsize, argsavename
			      C ;
			      C ;			set up frame to save regs, and to create aligned working memory for scratch variables
			      C ;			argsize is the amount of space to be made on on the stack for locals and padding (at least 40h on each end)
			      C ;			argsavename is the name of the variable, within the LOCAL declarations, QWORD, for the RBP to be saved, and restored from
			      C ;			No prologue, epilogue should be used. LOCAL declarations immediately after PROC statement, then this macro
			      C ;			Note: LOCAL variables will START on a 64 byte aligned address space. Your order and sizes of your variables will be in sequence as declared
			      C ;			and thus provide no assurance of alignment other than what your declarations imply. In other words, declaring a byte var at the beginning
			      C ;			throws everyting after that off by a byte. OK, not exacly, the asm will align by data type (eg, QWORD on 8 byte), but there is no way to get back
			      C ;			to 64 byte alignment, so declare those first, then QWORD, then DWORD, etc. Or, count your declares such that you get what/where you want.
			      C ;			example:
			      C ;
			      C ;somename	PROC
			      C ;			LOCAL		padding1[8]:QWORD				; warning: do not touch, initialize, or use padding. (on either end)
			      C ;			LOCAL		somelocal:ZMMWORD				; a 512 bit, 64 byte aligned var, ready for aligned load/store into ZMM (AVX2) register
			      C ;			LOCAL		some local variable declarions, some more, and some more
			      C ;			LOCAL		and some more
			      C ;			LOCAL		savedRBP:QWORD					; you might have other reg save space as well
			      C ;			LOCAL		padding2[8]:QWORD				; after your return statement, before ENDP, might LEA padding1 and padding2 to eliminate warning (unreferenced variables)
			      C ;			CREATEFRAME 200h, savedRBP (200h assumes 118h in those "some local variable declarations", adjust as necessary)
			      C ;
			      C ;			Use only one return from the PROC, and immediately before return, use RELEASEFRAME macro, giving name of where RBP is saved
			      C ;
			      C 			PUSH			RBP
			      C 			MOV				RBP, RSP
			      C 			ADD				RSP, -((argsize / 8) * ( 8 + 1)); make gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
			      C 			MOV				RAX, -64					; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
			      C 			AND				RSP, RAX
			      C 			AND				RAX, RBP					; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
			      C 			XCHG			RAX, RBP					; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
			      C 			MOV				argsavename, RAX			; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
			      C 			ENDM
			      C 
			      C ReleaseFrame MACRO			argsavename
			      C ;			release memory set up by createframe macro
			      C ;			restores RSP, and RBP to as-called values
			      C ;			after these instructions are executed, no LOCAL variables can be accessed
			      C ;			This needs to be done to restore the stack correctly, but can be done only once
			      C ;			Strongly suggest doing this just prior to return instruction, and that there is only one return instruction from the PROC
			      C 			MOV				RBP, argsavename
			      C 			LEAVE										; restore stack pointer (eliminating LOCAL storage), restore base pointer for caller
			      C 			ENDM
			      C 
			      C 
			      C ;==========================================================================================
			      C ;           Notes on x64 calling conventions        aka "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address
			      C ; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ;===========================================================================================
			      C ;
			      C ;===========================================================================================
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile,
			      C ;	and do not need to be saved
			      C ;  ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C ;===========================================================================================
			      C 
			      C ENDIF
			      C 

							OPTION			casemap:none
 00000000			.CODE
				;			EXTERNDEF		mult_u:PROC					;	void mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier)

				;			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, overflow
				;			Prototype:		-	void mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
				;			product			-	Address of 8 QWORDS to store resulting product (in RCX)
				;			overflow		-	Address of 8 QWORDS to store resulting overflow (in RDX)
				;			multiplicand	-	Address of 8 QWORDS multiplicand (in R8)
				;			multiplier		-	Address of 8 QWORDS multiplier (in R9)
				;			returns			-	nothing (0)

							OPTION			PROLOGUE:none
							OPTION			EPILOGUE:none
 00000000			mult_u		PROC			PUBLIC
							LOCAL			padding1[8]:QWORD
							LOCAL			product[16]:QWORD
							LOCAL			savedRCX:QWORD, savedRDX:QWORD, savedRBP:QWORD, savedR8:QWORD, savedR9:QWORD, savedR10:QWORD, savedR11:QWORD, savedR12:QWORD
							LOCAL			plierWC:WORD, candWC:WORD
							LOCAL			padding2[8]:QWORD
							CreateFrame		240h, savedRBP
 00000000  55		     1				PUSH			RBP
 00000001  48/ 8B EC	     1				MOV				RBP, RSP
 00000004  48/ 81 C4	     1				ADD				RSP, -((240h / 8) * ( 8 + 1)); make gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
	   FFFFFD78
 0000000B  48/ C7 C0	     1				MOV				RAX, -64					; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
	   FFFFFFC0
 00000012  48/ 23 E0	     1				AND				RSP, RAX
 00000015  48/ 23 C5	     1				AND				RAX, RBP					; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
 00000018  48/ 95	     1				XCHG			RAX, RBP					; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
 0000001A  48/ 89 85	     1				MOV				savedRBP, RAX			; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
	   FFFFFF28
 00000021  48/ 89 8D					MOV				savedRCX, RCX
	   FFFFFF38
 00000028  48/ 89 95					MOV				savedRDX, RDX
	   FFFFFF30
 0000002F  4C/ 89 85					MOV				savedR8, R8
	   FFFFFF20
 00000036  4C/ 89 8D					MOV				savedR9, R9
	   FFFFFF18
 0000003D  4C/ 89 95					MOV				savedR10, R10
	   FFFFFF10
 00000044  4C/ 89 9D					MOV				savedR11, R11
	   FFFFFF08
 0000004B  4C/ 89 A5					MOV				savedR12, R12
	   FFFFFF00
							;
 00000052  49/ 8B C8					MOV				RCX, R8						; examine multiplicand
 00000055  E8 00000000 E				CALL			msb_u
 0000005A  66| 83 F8 FF					CMP				AX, -1						; multiplicand = 0? exit with product = 0
 0000005E  74 38					JE				zeroandexit
 00000060  66| 83 F8 00					CMP				AX, 0						; multiplicand = 1?	exit with product = multiplier
 00000064  49/ 8B D1					MOV				RDX, R9						; address of multiplier (to be copied to product)
 00000067  74 5A					JE				copyandexit
 00000069  66| C1 E8 06					SHR				AX, 6
 0000006D  66| 89 85					MOV				candWC, AX					; save off word count for multiplicand
	   FFFFFEFC
							;
 00000074  49/ 8B C9					MOV				RCX, R9						; examine multiplier
 00000077  E8 00000000 E				CALL			msb_u
 0000007C  66| 83 F8 FF					CMP				AX, -1						; multiplier = 0? exit with product = 0
 00000080  74 16					JE				zeroandexit
 00000082  66| 83 F8 00					CMP				AX, 0						; multiplier = 1? exit with product = multiplicand
 00000086  49/ 8B D0					MOV				RDX, R8						; address of multiplicand (to be copied to product)
 00000089  74 38					JE				copyandexit
 0000008B  66| C1 E8 06					SHR				AX, 6
 0000008F  66| 89 85					MOV				plierWC, AX					; save off word count for multiplier
	   FFFFFEFE
 00000096  EB 56					JMP				mult
							;
 00000098			zeroandexit:
 00000098  48/ 8B 8D					MOV				RCX, savedRCX
	   FFFFFF38
							Zero512			RCX
 0000009F  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000000A5  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000000AB  48/ 8B 8D					MOV				RCX, savedRDX
	   FFFFFF30
							Zero512			RCX
 000000B2  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000000B8  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000000BE  E9 0000011C					JMP				exitmultnocopy
 000000C3			copyandexit:
 000000C3  48/ 8B 8D					MOV				RCX, savedRDX				; address of passed overflow
	   FFFFFF30
							Zero512			RCX 						; zero it
 000000CA  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000000D0  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000000D6  48/ 8B 8D					MOV				RCX, savedRCX				; copy (whichever: multiplier or multiplicand) to callers product
	   FFFFFF38
							Copy512			RCX, RDX
 000000DD  62 61 FD 48/ 6F   1				VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000000E3  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000000E9  E9 000000F1					JMP				exitmultnocopy				; and exit
 000000EE			mult:
 000000EE  48/ 8D 8D					LEA				RCX, product[0]
	   FFFFFF40
							Zero512			RCX							; clear working copy of overflow
 000000F5  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000000FB  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000101  48/ 8D 4D 80					LEA				RCX, product[8*8]
							Zero512			RCX							; clear working copy of product (they need to be contigous, so useing working copy, not callers)
 00000105  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000010B  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
							;
 00000111  4C/ 8B 9D					MOV				R11, savedR9				; address of callers multiplier
	   FFFFFF18
 00000118  49/ C7 C0					MOV				R8, 7
	   00000007
 0000011F  66| 44/ 2B 85				SUB				R8W, plierWC				 
	   FFFFFEFE
 00000127  66| 44/ 89 85				MOV				plierWC, R8W
	   FFFFFEFE
 0000012F  49/ C7 C0					MOV				R8, 7						; R8 : index for multiplier, plierWC : low limit for index
	   00000007
							;
 00000136  4C/ 8B A5					MOV				R12, savedR8				; address of callers multiplicand
	   FFFFFF20
 0000013D  49/ C7 C1					MOV				R9, 7
	   00000007
 00000144  66| 44/ 2B 8D				SUB				R9W, candWC
	   FFFFFEFC
 0000014C  66| 44/ 89 8D				MOV				candWC, R9W
	   FFFFFEFC
 00000154  49/ C7 C1					MOV				R9, 7						; R9 : index for multiplicand; candWC : low limit for index
	   00000007
							;
 0000015B			multloop:
 0000015B  4D/ 8B D0					MOV				R10, R8
 0000015E  4D/ 03 D1					ADD				R10, R9
 00000161  49/ FF C2					INC				R10							; R10 : index for product/overflow
							;
 00000164  4B/ 8B 04 CC					MOV				RAX, [R12] + [R9 * 8]
 00000168  4B/ F7 24 C3					MUL				Q_PTR [R11] + [R8 * 8]
 0000016C  4A/ 01 84 D5					ADD				product[R10 * 8], RAX
	   FFFFFF40
							;
 00000174  49/ FF CA					DEC				R10
 00000177			addcarryloop:
 00000177  4A/ 11 94 D5					ADC				product[R10 * 8], RDX
	   FFFFFF40
 0000017F  48/ C7 C2					MOV				RDX, 0
	   00000000
 00000186  73 05					JNC				nextcand
 00000188  49/ FF CA					DEC				R10
 0000018B  7D EA					JGE				addcarryloop
 0000018D			nextcand:
 0000018D  49/ FF C9					DEC				R9
 00000190  66| 44/ 3B 8D				CMP				R9W, candWC
	   FFFFFEFC
 00000198  7D C1					JGE				multloop
 0000019A  49/ C7 C1					MOV				R9, 7
	   00000007
 000001A1  49/ FF C8					DEC				R8
 000001A4  66| 44/ 3B 85				CMP				R8W, plierWC
	   FFFFFEFE
 000001AC  7D AD					JGE				multloop
				;			copy working product/overflow to callers product / overflow
 000001AE  48/ 8B 8D					MOV				RCX, savedRCX
	   FFFFFF38
 000001B5  48/ 8D 55 80					LEA				RDX, product[8 * 8]
							Copy512			RCX, RDX					; copy working product to callers product
 000001B9  62 61 FD 48/ 6F   1				VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000001BF  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000001C5  48/ 8B 8D					MOV				RCX, savedRDX
	   FFFFFF30
 000001CC  48/ 8D 95					LEA				RDX, product[0]
	   FFFFFF40
							Copy512			RCX, RDX					; copy working overflow to callers overflow
 000001D3  62 61 FD 48/ 6F   1				VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000001D9  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
				;			restore regs, release frame, return
 000001DF			exitmultnocopy:			
 000001DF  4C/ 8B A5					MOV				R12, savedR12
	   FFFFFF00
 000001E6  4C/ 8B 9D			MOV				R11, savedR11
	   FFFFFF08
 000001ED  4C/ 8B 95					MOV				R10, savedR10
	   FFFFFF10
 000001F4  4C/ 8B 8D					MOV				R9, savedR9
	   FFFFFF18
 000001FB  4C/ 8B 85					MOV				R8, savedR8
	   FFFFFF20
 00000202  48/ 8B 95					MOV				RDX, savedRDX
	   FFFFFF30
 00000209  48/ 8B 8D					MOV				RCX, savedRCX				; restore parameter registers back to "as-called" values
	   FFFFFF38
							ReleaseFrame	savedRBP
 00000210  48/ 8B AD	     1				MOV				RBP, savedRBP
	   FFFFFF28
 00000217  C9		     1				LEAVE										; restore stack pointer (eliminating LOCAL storage), restore base pointer for caller
 00000218  48/ 33 C0					XOR				RAX, RAX					; return zero
							RET
 0000021B  C3		   *	    ret    00000h
 0000021C  48/ 8D 45 C0					LEA				RAX, padding1				; reference local variables meant for padding to remove unreferenced variable warning from assembler
 00000220  48/ 8D 85					LEA				RAX, padding2
	   FFFFFEBC
 00000227			mult_u		ENDP

				;			EXTERNDEF		mult_uT64:PROC				;	void mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64* multiplier)

				;			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, overflow
				;			Prototype:		-	void mult_u( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
				;			product			-	Address of 8 QWORDS to store resulting product (in RCX)
				;			overflow		-	QWORD for resulting overflow (in RDX)
				;			multiplicand	-	Address of 8 QWORDS multiplicand (in R8)
				;			multiplier		-	multiplier QWORD (in R9)
				;			returns			-	nothing (0)
							OPTION			PROLOGUE:none
							OPTION			EPILOGUE:none
 00000227			mult_uT64	PROC			PUBLIC
							LOCAL			padding1[8]:QWORD
							LOCAL			product[16]:QWORD
							LOCAL			savedRCX:QWORD, savedRDX:QWORD, savedRBP:QWORD, savedR8:QWORD, savedR9:QWORD, savedR10:QWORD, savedR11:QWORD, savedR12:QWORD
							LOCAL			candWC:WORD
							LOCAL			padding2[8]:QWORD
							CreateFrame		200h, savedRBP
 00000227  55		     1				PUSH			RBP
 00000228  48/ 8B EC	     1				MOV				RBP, RSP
 0000022B  48/ 81 C4	     1				ADD				RSP, -((200h / 8) * ( 8 + 1)); make gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
	   FFFFFDC0
 00000232  48/ C7 C0	     1				MOV				RAX, -64					; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
	   FFFFFFC0
 00000239  48/ 23 E0	     1				AND				RSP, RAX
 0000023C  48/ 23 C5	     1				AND				RAX, RBP					; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
 0000023F  48/ 95	     1				XCHG			RAX, RBP					; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
 00000241  48/ 89 85	     1				MOV				savedRBP, RAX			; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
	   FFFFFF28
 00000248  48/ 89 8D					MOV				savedRCX, RCX
	   FFFFFF38
 0000024F  48/ 89 95					MOV				savedRDX, RDX
	   FFFFFF30
 00000256  4C/ 89 85					MOV				savedR8, R8
	   FFFFFF20
 0000025D  4C/ 89 8D					MOV				savedR9, R9
	   FFFFFF18
 00000264  4C/ 89 95					MOV				savedR10, R10
	   FFFFFF10
 0000026B  4C/ 89 9D					MOV				savedR11, R11
	   FFFFFF08
 00000272  4C/ 89 A5					MOV				savedR12, R12
	   FFFFFF00
							;
 00000279  49/ 8B C8					MOV				RCX, R8						; examine multiplicand
 0000027C  E8 00000000 E				CALL			msb_u
 00000281  66| 83 F8 FF					CMP				AX, -1						; multiplicand = 0? exit with product = 0
 00000285  74 1F					JE				zeroandexit
 00000287  66| 83 F8 00					CMP				AX, 0						; multiplicand = 1?	exit with product = multiplier
 0000028B  74 3B					JE				setandexit
 0000028D  66| C1 E8 06					SHR				AX, 6
 00000291  66| 89 85					MOV				candWC, AX					; save off word count for multiplicand
	   FFFFFEFE
							;
 00000298  49/ 0F BD 01					BSR				RAX, [R9]					; examine multiplier
 0000029C  74 08					JZ				zeroandexit					; multiplier = 0? exit with product = 0
 0000029E  66| 83 F8 00					CMP				AX, 0						; multiplier = 1? exit with product = multiplicand			
 000002A2  74 46					JE				settocandandexit
 000002A4  EB 66					JMP				mult
							;
 000002A6			zeroandexit:
 000002A6  48/ 8B 8D					MOV				RCX, savedRCX				; callers product set to zero
	   FFFFFF38
							Zero512			RCX
 000002AD  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000002B3  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000002B9  48/ 33 C0					XOR				RAX, RAX
 000002BC  48/ 89 85					MOV				savedRDX, RAX				; callers overflow to zero
	   FFFFFF30
 000002C3  E9 000000F8					JMP				exitmultnocopy
 000002C8			setandexit:
 000002C8  48/ 8B 8D					MOV				RCX, savedRCX
	   FFFFFF38
 000002CF  48/ 8B 95					MOV				RDX, savedR9
	   FFFFFF18
 000002D6  E8 00000000 E				CALL			set_uT64					; set product to multiplier
 000002DB  48/ 33 C0					XOR				RAX, RAX
 000002DE  48/ 89 85					MOV				savedRDX, RAX				; callers overflow to zero
	   FFFFFF30
 000002E5  E9 000000D6					JMP				exitmultnocopy				; and exit
 000002EA			settocandandexit:
 000002EA  48/ 8B 8D					MOV				RCX, savedRCX				; copy (multiplicand) to callers product
	   FFFFFF38
							Copy512			RCX, R8						; address of multiplicand (to be copied to product)
 000002F1  62 41 FD 48/ 6F   1				VMOVDQA64		ZMM31, ZM_PTR [ R8 ]
	   38
 000002F7  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000002FD  48/ 33 C0					XOR				RAX, RAX
 00000300  48/ 89 85					MOV				savedRDX, RAX				; callers overflow to zero
	   FFFFFF30
 00000307  E9 000000B4					JMP				exitmultnocopy				; and exit
 0000030C			mult:
 0000030C  48/ 8D 8D					LEA				RCX, product
	   FFFFFF40
							Zero512			RCX							; clear working copy of product (they need to be contigous, so using working copy, not callers)
 00000313  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000319  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000031F  48/ 33 C0					XOR				RAX, RAX
 00000322  48/ 89 45 80					MOV				product [ 8 * 8 ], RAX		; 
							;
 00000326  4C/ 8B 9D					MOV				R11, savedR9				; multiplier 
	   FFFFFF18
 0000032D  4C/ 8B A5					MOV				R12, savedR8				; address of callers multiplicand
	   FFFFFF20
 00000334  49/ C7 C1					MOV				R9, 7
	   00000007
 0000033B  66| 44/ 2B 8D				SUB				R9W, candWC
	   FFFFFEFE
 00000343  66| 44/ 89 8D				MOV				candWC, R9W
	   FFFFFEFE
 0000034B  49/ C7 C1					MOV				R9, 7						; R9 : index for multiplicand; candWC : low limit for index
	   00000007
							;
 00000352			multloop:
 00000352  4D/ 8B D1					MOV				R10, R9
 00000355  49/ FF C2					INC				R10							; R10 : index for product/overflow
							;
 00000358  4B/ 8B 04 CC					MOV				RAX, [R12] + [R9 * 8]
 0000035C  49/ F7 23					MUL				Q_PTR [R11]
 0000035F  4A/ 01 84 D5					ADD				product[R10 * 8], RAX
	   FFFFFF40
							;
 00000367  49/ FF CA					DEC				R10
 0000036A			addcarryloop:
 0000036A  4A/ 11 94 D5					ADC				product[R10 * 8], RDX
	   FFFFFF40
 00000372  48/ C7 C2					MOV				RDX, 0
	   00000000
 00000379  73 05					JNC				nextcand
 0000037B  49/ FF CA					DEC				R10
 0000037E  7D EA					JGE				addcarryloop
 00000380			nextcand:
 00000380  49/ FF C9					DEC				R9
 00000383  66| 44/ 3B 8D				CMP				R9W, candWC
	   FFFFFEFE
 0000038B  7D C5					JGE				multloop
				;			copy working product/overflow to callers product / overflow
 0000038D  49/ C7 C1					MOV				R9, 7
	   00000007
 00000394  48/ 8B 8D					MOV				RCX, savedRCX
	   FFFFFF38
 0000039B  48/ 8D 95					LEA				RDX, product[1 * 8]			; this is not 64 byte aligned, can not use copy_u
	   FFFFFF48
 000003A2			copyloop:
 000003A2  4A/ 8B 04 CA					MOV				RAX, [RDX] + [R9 * 8]
 000003A6  4A/ 89 04 C9					MOV				[RCX] + [R9 * 8], RAX
 000003AA  49/ FF C9					DEC				R9
 000003AD  7D F3					JGE				copyloop
 000003AF  48/ 8B 85					MOV				RAX, product [ 0 ]
	   FFFFFF40
 000003B6  48/ 8B 95					MOV				RDX, savedRDX
	   FFFFFF30
 000003BD  48/ 89 02					MOV				[RDX], RAX				; callers overflow to zero

				;			restore regs, release frame, return
 000003C0			exitmultnocopy:			
 000003C0  4C/ 8B A5					MOV				R12, savedR12
	   FFFFFF00
 000003C7  4C/ 8B 9D					MOV				R11, savedR11
	   FFFFFF08
 000003CE  4C/ 8B 95					MOV				R10, savedR10
	   FFFFFF10
 000003D5  4C/ 8B 8D					MOV				R9,  savedR9
	   FFFFFF18
 000003DC  4C/ 8B 85					MOV				R8,  savedR8
	   FFFFFF20
 000003E3  48/ 8B 95					MOV				RDX, savedRDX
	   FFFFFF30
 000003EA  48/ 8B 8D					MOV				RCX, savedRCX				; restore parameter registers back to "as-called" values
	   FFFFFF38
							ReleaseFrame	savedRBP
 000003F1  48/ 8B AD	     1				MOV				RBP, savedRBP
	   FFFFFF28
 000003F8  C9		     1				LEAVE										; restore stack pointer (eliminating LOCAL storage), restore base pointer for caller
 000003F9  48/ 33 C0					XOR				RAX, RAX					; return zero
							RET
 000003FC  C3		   *	    ret    00000h
 000003FD  48/ 8D 45 C0					LEA				RAX, padding1				; reference local variables meant for padding to remove unreferenced variable warning from assembler
 00000401  48/ 8D 85					LEA				RAX, padding2
	   FFFFFEBC

 00000408			mult_uT64	ENDP

				;			EXTERNDEF		div_u:PROC					; s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor)

				;			div_u			-	divide 512 dividend by 512 divisor, giving 512 quotient, remainder
				;			Prototype:		-	void mult_u( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
				;			quotient		-	Address of 8 QWORDS to store resulting quotient (in RCX)
				;			remainder		-	Address of 8 QWORDs for resulting remainder (in RDX)
				;			dividend		-	Address of 8 QWORDS dividend (in R8)
				;			divisor			-	Address of 8 QWORDs divisor (in R9)
				;			returns			-	nothing (0)
							OPTION			PROLOGUE:none
							OPTION			EPILOGUE:none
 00000408			div_u		PROC			PUBLIC
							LOCAL			padding1[8]:QWORD
							LOCAL			qhat[16]:QWORD
							LOCAL			rhat[8]:QWORD
							LOCAL			quotient[16]:QWORD
							LOCAL			savedRCX:QWORD, savedRDX:QWORD, savedRBP:QWORD, savedR8:QWORD, savedR9:QWORD, savedR10:QWORD, savedR11:QWORD, savedR12:QWORD
							LOCAL			dadj:QWORD					; normalization adjustment
							LOCAL			mbitn:WORD, lbitn:WORD, initn:WORD		; initial count of words of "u", the dividend aka numerator aka the number on top (zero-based, so zero to count-1)
							LOCAL			mbitm:WORD, lbitm:WORD, initm:WORD		; initial count of words of "v", the divisor aka denominator aka the number on the bottom (u / v)
							LOCAL			normd:WORD					; value of normalizing variable d which is set to (radix - 1 over v sub n - 1)
							LOCAL			loopj:WORD					; loop iterator, initially "m"
							LOCAL			shiftadj:WORD				; divisor adjustment to fit into one word
							LOCAL			padding2[8]:QWORD
							CreateFrame		240h, savedRBP
 00000408  55		     1				PUSH			RBP
 00000409  48/ 8B EC	     1				MOV				RBP, RSP
 0000040C  48/ 81 C4	     1				ADD				RSP, -((240h / 8) * ( 8 + 1)); make gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
	   FFFFFD78
 00000413  48/ C7 C0	     1				MOV				RAX, -64					; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
	   FFFFFFC0
 0000041A  48/ 23 E0	     1				AND				RSP, RAX
 0000041D  48/ 23 C5	     1				AND				RAX, RBP					; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
 00000420  48/ 95	     1				XCHG			RAX, RBP					; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
 00000422  48/ 89 85	     1				MOV				savedRBP, RAX			; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
	   FFFFFE68
 00000429  48/ 89 8D					MOV				savedRCX, RCX
	   FFFFFE78
 00000430  48/ 89 95					MOV				savedRDX, RDX
	   FFFFFE70
 00000437  4C/ 89 85					MOV				savedR8, R8
	   FFFFFE60
 0000043E  4C/ 89 8D					MOV				savedR9, R9
	   FFFFFE58
 00000445  4C/ 89 95					MOV				savedR10, R10
	   FFFFFE50
 0000044C  4C/ 89 9D					MOV				savedR11, R11
	   FFFFFE48
 00000453  4C/ 89 A5					MOV				savedR12, R12
	   FFFFFE40
							;
 0000045A  48/ 8D 8D					LEA				RCX, quotient
	   FFFFFE80
							Zero512			RCX
 00000461  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000467  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000046D  48/ 8D 8D					LEA				RCX, quotient [ 8 * 8]
	   FFFFFEC0
							Zero512			RCX
 00000474  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000047A  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000480  48/ 8D 8D					LEA				RCX, qhat
	   FFFFFF40
							Zero512			RCX
 00000487  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000048D  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000493  48/ 8D 8D					LEA				RCX, rhat
	   FFFFFF00
							Zero512			RCX
 0000049A  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000004A0  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000004A6  48/ 33 C0					XOR				RAX, RAX
 000004A9  48/ 89 85					MOV				dadj, RAX
	   FFFFFE38
 000004B0  66| 89 85					MOV				normd, AX
	   FFFFFE2A
 000004B7  66| 89 85					MOV				loopj, AX
	   FFFFFE28
 000004BE  66| 89 85					MOV				shiftadj, AX
	   FFFFFE26
							; D1 [Normalize]
							;	Determine dimensions of u and v (dividend and divisor)
							;		Shift if it gets divisor to single or reduced words
							;		Handle edge cases of divisor = 0, or 1, or power of 2
							;	Add an extra word on the front of u
							;	Multiply (again shift) by "d" (chosen as power of two)
 000004C5  48/ 8B 8D					MOV				RCX, savedR8				; get dimensions of dividend
	   FFFFFE60
 000004CC  E8 00000000 E				CALL			msb_u
 000004D1  66| 89 85					MOV				mbitn, AX
	   FFFFFE36
 000004D8  66| C1 E8 06					SHR				AX, 6
 000004DC  66| 89 85					MOV				initn, AX
	   FFFFFE32
 000004E3  E8 00000000 E				CALL			lsb_u
 000004E8  66| 89 85					MOV				lbitn, AX
	   FFFFFE34
							;
 000004EF  48/ 8B 8D					MOV				RCX, savedR9				; dimensions of divisor
	   FFFFFE58
 000004F6  E8 00000000 E				CALL			msb_u						; count til most significant bit
 000004FB  66| 89 85					MOV				mbitm, AX
	   FFFFFE30
 00000502  66| C1 E8 06					SHR				AX, 6
 00000506  66| 89 85					MOV				initm, AX
	   FFFFFE2C
 0000050D  E8 00000000 E				CALL			lsb_u						; count to least significant bit
 00000512  66| 89 85					MOV				lbitm, AX
	   FFFFFE2E
							;
 00000519  66| 8B 85					MOV				AX, mbitm					; divisor edge cases (zero? power of two? one?)
	   FFFFFE30
 00000520  66| 83 F8 00					CMP				AX, 0						; msb < 0? 
 00000524  0F 8C 000000BE				JL				cleanret					; divisor is zero, abort (Note: no indication of fail)
 0000052A  66| 3B 85					CMP				AX, lbitm					; msb = lsb? power of two (or one)
	   FFFFFE2E
 00000531  75 60					JNZ				notpow2

							;	for power of two divisor (or one), shift, with shifted out bits going to remainder, exit

 00000533  48/ 8B 95					MOV				RDX, savedR8				; address of dividend
	   FFFFFE60
 0000053A  48/ 8B 8D					MOV				RCX, savedRDX				; address of callers remainder
	   FFFFFE70
 00000541  49/ C7 C0					MOV				R8, 512
	   00000200
 00000548  66| 44/ 2B 85				SUB				R8W, lbitm					; shift out all high bits
	   FFFFFE2E
 00000550  E8 00000000 E				CALL			shl_u
 00000555  48/ 8B 95					MOV				RDX, savedRDX
	   FFFFFE70
 0000055C  48/ 8B CA					MOV				RCX, RDX
 0000055F  49/ C7 C0					MOV				R8, 512
	   00000200
 00000566  66| 44/ 2B 85				SUB				R8W, lbitm
	   FFFFFE2E
 0000056E  E8 00000000 E				CALL			shr_u						; shift back with destination the remainder, eliminating high bits
 00000573  48/ 8B 8D					MOV				RCX, savedRCX				; callers quotient (even if zero bits shifted, this copies to callers vars)
	   FFFFFE78
 0000057A  48/ 8B 95					MOV				RDX, savedR8				; callers dividend
	   FFFFFE60
 00000581  4D/ 33 C0					XOR				R8, R8
 00000584  66| 44/ 8B 85				MOV				R8W, lbitm
	   FFFFFE2E
 0000058C  E8 00000000 E				CALL			shr_u						; shift dividend n bits to make quotient
 00000591  EB 55					JMP				cleanret
 00000593			notpow2:
 00000593  66| 8B 85					MOV				AX, mbitm
	   FFFFFE30
 0000059A  66| 83 F0 3F					XOR				AX, 03fh
 0000059E  66| 83 F8 3C					CMP				AX, 60
 000005A2  7D 13					JGE				no_d_adj
 000005A4  66| 41/ B8					MOV				R8W, 63
	   003F
 000005A9  66| 44/ 2B C0				SUB				R8W, AX
 000005AD  66| 44/ 89 85				MOV				normd, R8W
	   FFFFFE2A
 000005B5  EB 0A					JMP				copyw
 000005B7			no_d_adj:
 000005B7  48/ 33 C0					XOR				RAX, RAX
 000005BA  66| 89 85					MOV				normd, AX
	   FFFFFE2A

							; copy to work area, adding extra leading word, shifting (mult) by 'd'
 000005C1			copyw:
							; shift is at most 62 bits, so get bits from first word
 000005C1  48/ 8B 95					MOV				RDX, savedR9				; address of divisor
	   FFFFFE58
 000005C8  48/ C7 C1					MOV				RCX, 7
	   00000007
 000005CF  66| 2B 8D					SUB				CX, initm
	   FFFFFE2C
 000005D6  48/ 8D 14 CA					LEA				RDX, [RDX] + [RCX * 8]


							; D2 [Initialize]
							;	loop counter "j", starting at word count of u ("m")
 000005DA  66| 8B 85					MOV				AX, initm
	   FFFFFE2C
 000005E1  66| 89 85					MOV				loopj, AX
	   FFFFFE28
							; D3 [Calculate q]
							;	Initial guess q is qhat, remainder r is rhat
							;	two leading words of u / leading word of v, remainder rhat
							;	test = to radix or greater than second word u times qhat + radix times rhat
							;		adjust if so: decrease qhat by one, add leading word of v to rhat, repeat if rhat < radix

							; D4 [Multiply and subtract]
							;	Multiply qhat by adjusted v
							;	Subtract from adjusted u
							;	Test for negative

							; D5 [Test remainder]
							;	qhat to Q sub j
							;	"go to" add back (D6) if negative, else loop on j [D7]

							; D6 [Add back]
							;	decrease Q sub j by one
							;	Add adjusted v with leading zero to adjusted u sub n +j ...

							; D7 [Loop on j]
							;	decrease j by one
							;	j >= 0 "go to" D3

							; D8 [Un Normalize]
							;	Q is now quotient
							;	Divide remaining u by d for remainder

							;	Clean up and return
							;   
							;
 000005E8			cleanret:
 000005E8  4C/ 8B A5					MOV				R12, savedR12
	   FFFFFE40
 000005EF  4C/ 8B 9D					MOV				R11, savedR11
	   FFFFFE48
 000005F6  4C/ 8B 95					MOV				R10, savedR10
	   FFFFFE50
 000005FD  4C/ 8B 8D					MOV				R9,  savedR9
	   FFFFFE58
 00000604  4C/ 8B 85					MOV				R8,  savedR8
	   FFFFFE60
 0000060B  48/ 8B 95					MOV				RDX, savedRDX
	   FFFFFE70
 00000612  48/ 8B 8D					MOV				RCX, savedRCX				; restore parameter registers back to "as-called" values
	   FFFFFE78
							ReleaseFrame	savedRBP
 00000619  48/ 8B AD	     1				MOV				RBP, savedRBP
	   FFFFFE68
 00000620  C9		     1				LEAVE										; restore stack pointer (eliminating LOCAL storage), restore base pointer for caller
 00000621  48/ 33 C0					XOR				RAX, RAX					; return zero
							RET
 00000624  C3		   *	    ret    00000h
 00000625  48/ 8D 45 C0					LEA				RAX, padding1				; reference local variables meant for padding to remove unreferenced variable warning from assembler
 00000629  48/ 8D 85					LEA				RAX, padding2
	   FFFFFDE4
 00000630			div_u		ENDP

				;			EXTERNDEF		div_uT64:PROC				; s16 div_uT64( u64* quotient, u64 remainder, u64* dividend, u64 divisor)
							OPTION			PROLOGUE:none
							OPTION			EPILOGUE:none
 00000630			div_uT64	PROC			PUBLIC
							LOCAL			padding1[8]:QWORD
							LOCAL			quotient[16]:QWORD
							LOCAL			savedRCX:QWORD, savedRDX:QWORD, savedRBP:QWORD, savedR8:QWORD, savedR9:QWORD, savedR10:QWORD, savedR11:QWORD, savedR12:QWORD
							LOCAL			padding2[8]:QWORD
							CreateFrame		200h, savedRBP
 00000630  55		     1				PUSH			RBP
 00000631  48/ 8B EC	     1				MOV				RBP, RSP
 00000634  48/ 81 C4	     1				ADD				RSP, -((200h / 8) * ( 8 + 1)); make gap between old stack pointer and current stack pointer for use as "LOCAL", adjust size if changes made to locals
	   FFFFFDC0
 0000063B  48/ C7 C0	     1				MOV				RAX, -64					; Round it (down), to make it, and local vars, align on 64 byte address (necessary for aligned ZMM load/store)
	   FFFFFFC0
 00000642  48/ 23 E0	     1				AND				RSP, RAX
 00000645  48/ 23 C5	     1				AND				RAX, RBP					; note: "padding" variables must not be used. They are in areas where we have just rounded down, or in stack space for those we call
 00000648  48/ 95	     1				XCHG			RAX, RBP					; RBP now points to top of gap between old stack pointer and current stack pointer, aligned on 64
 0000064A  48/ 89 85	     1				MOV				savedRBP, RAX			; LOCAL variables now usable, using negative offsets from the new RBP value. Must restore RBP, RSP at exit (Use RELEASEFRAME)
	   FFFFFF28
 00000651  48/ 89 8D					MOV				savedRCX, RCX
	   FFFFFF38
 00000658  48/ 89 95					MOV				savedRDX, RDX
	   FFFFFF30
 0000065F  4C/ 89 85					MOV				savedR8, R8
	   FFFFFF20
 00000666  4C/ 89 8D					MOV				savedR9, R9
	   FFFFFF18
 0000066D  4C/ 89 95					MOV				savedR10, R10
	   FFFFFF10
 00000674  4C/ 89 9D					MOV				savedR11, R11
	   FFFFFF08
 0000067B  4C/ 89 A5					MOV				savedR12, R12
	   FFFFFF00
							;
 00000682  48/ 8D 8D					LEA				RCX, quotient
	   FFFFFF40
							Zero512			RCX
 00000689  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000068F  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000695  48/ 8D 4D 80					LEA				RCX, quotient [ 8 * 8]
							Zero512			RCX
 00000699  62 01 85 40/ EF   1				VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000069F  62 61 FD 48/ 7F   1				VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39

							;
 000006A5  4C/ 8B A5					MOV				R12, savedR12
	   FFFFFF00
 000006AC  4C/ 8B 9D					MOV				R11, savedR11
	   FFFFFF08
 000006B3  4C/ 8B 95					MOV				R10, savedR10
	   FFFFFF10
 000006BA  4C/ 8B 8D					MOV				R9,  savedR9
	   FFFFFF18
 000006C1  4C/ 8B 85					MOV				R8,  savedR8
	   FFFFFF20
 000006C8  48/ 8B 95					MOV				RDX, savedRDX
	   FFFFFF30
 000006CF  48/ 8B 8D					MOV				RCX, savedRCX				; restore parameter registers back to "as-called" values
	   FFFFFF38
							ReleaseFrame	savedRBP
 000006D6  48/ 8B AD	     1				MOV				RBP, savedRBP
	   FFFFFF28
 000006DD  C9		     1				LEAVE										; restore stack pointer (eliminating LOCAL storage), restore base pointer for caller
 000006DE  48/ 33 C0					XOR				RAX, RAX					; return zero
							RET
 000006E1  C3		   *	    ret    00000h
 000006E2  48/ 8D 45 C0					LEA				RAX, padding1				; reference local variables meant for padding to remove unreferenced variable warning from assembler
 000006E6  48/ 8D 85					LEA				RAX, padding2
	   FFFFFEC0
 000006ED			div_uT64	ENDP

							END
Microsoft (R) Macro Assembler (x64) Version 14.40.33811.0   06/16/24 18:10:57
ui512md.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

Copy512  . . . . . . . . . . . .	Proc
CreateFrame  . . . . . . . . . .	Proc
ReleaseFrame . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

div_uT64 . . . . . . . . . . . .	P 	 00000630 _TEXT	Length= 000000BD Public
  padding1 . . . . . . . . . . .	QWord	 rbp - 00000040
  quotient . . . . . . . . . . .	QWord	 rbp - 000000C0
  savedRCX . . . . . . . . . . .	QWord	 rbp - 000000C8
  savedRDX . . . . . . . . . . .	QWord	 rbp - 000000D0
  savedRBP . . . . . . . . . . .	QWord	 rbp - 000000D8
  savedR8  . . . . . . . . . . .	QWord	 rbp - 000000E0
  savedR9  . . . . . . . . . . .	QWord	 rbp - 000000E8
  savedR10 . . . . . . . . . . .	QWord	 rbp - 000000F0
  savedR11 . . . . . . . . . . .	QWord	 rbp - 000000F8
  savedR12 . . . . . . . . . . .	QWord	 rbp - 00000100
  padding2 . . . . . . . . . . .	QWord	 rbp - 00000140
div_u  . . . . . . . . . . . . .	P 	 00000408 _TEXT	Length= 00000228 Public
  padding1 . . . . . . . . . . .	QWord	 rbp - 00000040
  qhat . . . . . . . . . . . . .	QWord	 rbp - 000000C0
  rhat . . . . . . . . . . . . .	QWord	 rbp - 00000100
  quotient . . . . . . . . . . .	QWord	 rbp - 00000180
  savedRCX . . . . . . . . . . .	QWord	 rbp - 00000188
  savedRDX . . . . . . . . . . .	QWord	 rbp - 00000190
  savedRBP . . . . . . . . . . .	QWord	 rbp - 00000198
  savedR8  . . . . . . . . . . .	QWord	 rbp - 000001A0
  savedR9  . . . . . . . . . . .	QWord	 rbp - 000001A8
  savedR10 . . . . . . . . . . .	QWord	 rbp - 000001B0
  savedR11 . . . . . . . . . . .	QWord	 rbp - 000001B8
  savedR12 . . . . . . . . . . .	QWord	 rbp - 000001C0
  dadj . . . . . . . . . . . . .	QWord	 rbp - 000001C8
  mbitn  . . . . . . . . . . . .	Word	 rbp - 000001CA
  lbitn  . . . . . . . . . . . .	Word	 rbp - 000001CC
  initn  . . . . . . . . . . . .	Word	 rbp - 000001CE
  mbitm  . . . . . . . . . . . .	Word	 rbp - 000001D0
  lbitm  . . . . . . . . . . . .	Word	 rbp - 000001D2
  initm  . . . . . . . . . . . .	Word	 rbp - 000001D4
  normd  . . . . . . . . . . . .	Word	 rbp - 000001D6
  loopj  . . . . . . . . . . . .	Word	 rbp - 000001D8
  shiftadj . . . . . . . . . . .	Word	 rbp - 000001DA
  padding2 . . . . . . . . . . .	QWord	 rbp - 0000021C
  notpow2  . . . . . . . . . . .	L 	 00000593 _TEXT	
  no_d_adj . . . . . . . . . . .	L 	 000005B7 _TEXT	
  copyw  . . . . . . . . . . . .	L 	 000005C1 _TEXT	
  cleanret . . . . . . . . . . .	L 	 000005E8 _TEXT	
mult_uT64  . . . . . . . . . . .	P 	 00000227 _TEXT	Length= 000001E1 Public
  padding1 . . . . . . . . . . .	QWord	 rbp - 00000040
  product  . . . . . . . . . . .	QWord	 rbp - 000000C0
  savedRCX . . . . . . . . . . .	QWord	 rbp - 000000C8
  savedRDX . . . . . . . . . . .	QWord	 rbp - 000000D0
  savedRBP . . . . . . . . . . .	QWord	 rbp - 000000D8
  savedR8  . . . . . . . . . . .	QWord	 rbp - 000000E0
  savedR9  . . . . . . . . . . .	QWord	 rbp - 000000E8
  savedR10 . . . . . . . . . . .	QWord	 rbp - 000000F0
  savedR11 . . . . . . . . . . .	QWord	 rbp - 000000F8
  savedR12 . . . . . . . . . . .	QWord	 rbp - 00000100
  candWC . . . . . . . . . . . .	Word	 rbp - 00000102
  padding2 . . . . . . . . . . .	QWord	 rbp - 00000144
  zeroandexit  . . . . . . . . .	L 	 000002A6 _TEXT	
  setandexit . . . . . . . . . .	L 	 000002C8 _TEXT	
  settocandandexit . . . . . . .	L 	 000002EA _TEXT	
  mult . . . . . . . . . . . . .	L 	 0000030C _TEXT	
  multloop . . . . . . . . . . .	L 	 00000352 _TEXT	
  addcarryloop . . . . . . . . .	L 	 0000036A _TEXT	
  nextcand . . . . . . . . . . .	L 	 00000380 _TEXT	
  copyloop . . . . . . . . . . .	L 	 000003A2 _TEXT	
  exitmultnocopy . . . . . . . .	L 	 000003C0 _TEXT	
mult_u . . . . . . . . . . . . .	P 	 00000000 _TEXT	Length= 00000227 Public
  padding1 . . . . . . . . . . .	QWord	 rbp - 00000040
  product  . . . . . . . . . . .	QWord	 rbp - 000000C0
  savedRCX . . . . . . . . . . .	QWord	 rbp - 000000C8
  savedRDX . . . . . . . . . . .	QWord	 rbp - 000000D0
  savedRBP . . . . . . . . . . .	QWord	 rbp - 000000D8
  savedR8  . . . . . . . . . . .	QWord	 rbp - 000000E0
  savedR9  . . . . . . . . . . .	QWord	 rbp - 000000E8
  savedR10 . . . . . . . . . . .	QWord	 rbp - 000000F0
  savedR11 . . . . . . . . . . .	QWord	 rbp - 000000F8
  savedR12 . . . . . . . . . . .	QWord	 rbp - 00000100
  plierWC  . . . . . . . . . . .	Word	 rbp - 00000102
  candWC . . . . . . . . . . . .	Word	 rbp - 00000104
  padding2 . . . . . . . . . . .	QWord	 rbp - 00000144
  zeroandexit  . . . . . . . . .	L 	 00000098 _TEXT	
  copyandexit  . . . . . . . . .	L 	 000000C3 _TEXT	
  mult . . . . . . . . . . . . .	L 	 000000EE _TEXT	
  multloop . . . . . . . . . . .	L 	 0000015B _TEXT	
  addcarryloop . . . . . . . . .	L 	 00000177 _TEXT	
  nextcand . . . . . . . . . . .	L 	 0000018D _TEXT	
  exitmultnocopy . . . . . . . .	L 	 000001DF _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__UseQ . . . . . . . . . . . . .	Number	 00000000h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000001h   
add_uT64 . . . . . . . . . . . .	L 	 00000000 External
add_u  . . . . . . . . . . . . .	L 	 00000000 External
and_u  . . . . . . . . . . . . .	L 	 00000000 External
compare_uT64 . . . . . . . . . .	L 	 00000000 External
compare_u  . . . . . . . . . . .	L 	 00000000 External
copy_u . . . . . . . . . . . . .	L 	 00000000 External
lsb_u  . . . . . . . . . . . . .	L 	 00000000 External
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
msb_u  . . . . . . . . . . . . .	L 	 00000000 External
not_u  . . . . . . . . . . . . .	L 	 00000000 External
or_u . . . . . . . . . . . . . .	L 	 00000000 External
set_uT64 . . . . . . . . . . . .	L 	 00000000 External
shl_u  . . . . . . . . . . . . .	L 	 00000000 External
shr_u  . . . . . . . . . . . . .	L 	 00000000 External
sub_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_u  . . . . . . . . . . . . .	L 	 00000000 External
ui512aMacros_INC . . . . . . . .	Text   	 1
ui512bMacros_INC . . . . . . . .	Text   	 1
ui512mdMacros_INC  . . . . . . .	Text   	 1
zero_u . . . . . . . . . . . . .	L 	 00000000 External

	   0 Warnings
	   0 Errors
